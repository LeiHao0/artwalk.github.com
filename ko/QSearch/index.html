<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/ko/images/logo-192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/ko/images/logo-192.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/ko/images/logo.png">
  <link rel="mask-icon" href="/ko/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="rbaH_zC-qBwXaawJ10Mno3FHzv9HRFHGFdXx2f1BwyI">

<link rel="stylesheet" href="/ko/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">

<script data-ad-client="ca-pub-2317298287519457" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leihao0.github.io","root":"/ko/","scheme":"Pisces","version":"8.0.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/ko/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="연구 내용   NTFS MFT 읽기  해시 테이블 구성  파일의 시스템 경로  GUI 및 작업자 스레드  여러 검색 방법  MFC 인터페이스   연구 계획   연구 방향 결정을위한 4 월 초 ~ 4 월 중순  4 월 말부터 4 월 말까지 지식 포인트 별 준비, 간단한 시험  5 월 초 프로그램 설계 및 개발 디버깅 및 운영  5 월 중순 5 월 말 졸업 디">
<meta property="og:type" content="article">
<meta property="og:title" content="모든 것의 원리 추측과 실현">
<meta property="og:url" content="https://leihao0.github.io/ko/QSearch/index.html">
<meta property="og:site_name" content="LeiHao&#39;s Blog">
<meta property="og:description" content="연구 내용   NTFS MFT 읽기  해시 테이블 구성  파일의 시스템 경로  GUI 및 작업자 스레드  여러 검색 방법  MFC 인터페이스   연구 계획   연구 방향 결정을위한 4 월 초 ~ 4 월 중순  4 월 말부터 4 월 말까지 지식 포인트 별 준비, 간단한 시험  5 월 초 프로그램 설계 및 개발 디버깅 및 운영  5 월 중순 5 월 말 졸업 디">
<meta property="og:locale" content="ko_KR">
<meta property="article:published_time" content="2012-05-26T14:44:42.000Z">
<meta property="article:modified_time" content="2020-12-20T23:53:08.329Z">
<meta property="article:author" content="LeiHao">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Everything">
<meta property="article:tag" content="NTFS">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://leihao0.github.io/ko/QSearch/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'ko'
  };
</script>

  <title>모든 것의 원리 추측과 실현 | LeiHao's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-159363268-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-159363268-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?25f016f633270b8e0baf56c4fe6f2dc1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/ko/atom.xml" title="LeiHao's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/ko/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LeiHao's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/ko/" rel="section"><i class="fa fa-home fa-fw"></i>홈</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/ko/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/ko/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>아카이브</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/ko/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>검색
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#NTFS-%EB%94%94%EC%8A%A4%ED%81%AC-%ED%8C%8C%EC%9D%BC%EC%9D%98-%EB%B9%A0%EB%A5%B8-%EC%9C%84%EC%B9%98"><span class="nav-number">1.</span> <span class="nav-text">NTFS 디스크 파일의 빠른 위치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%EC%86%8C%EA%B0%9C"><span class="nav-number">1.1.</span> <span class="nav-text">1. 소개</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-NTFS%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%9E%B5%ED%95%9C-%EC%86%8C%EA%B0%9C"><span class="nav-number">1.2.</span> <span class="nav-text">2 NTFS에 대한 간략한 소개</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-NTFS"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 NTFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%ED%98%84%EC%9E%AC-%EC%83%81%ED%99%A9"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 현재 상황</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%EC%A4%80%EB%B9%84"><span class="nav-number">1.3.</span> <span class="nav-text">3 준비</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%EB%94%94%EC%9E%90%EC%9D%B8-%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 디자인 아이디어</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-USN%EC%9D%B4%EB%9E%80"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 USN이란?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%EB%B9%A0%EB%A5%B8-%EC%9D%B4%EC%9C%A0"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 빠른 이유</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%ED%99%98%EA%B2%BD"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 환경</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89"><span class="nav-number">1.4.</span> <span class="nav-text">4 프로그램 실행</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-USN-%EC%9D%BD%EA%B8%B0"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 USN 읽기</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%EB%94%94%EC%8A%A4%ED%81%AC-%ED%98%95%EC%8B%9D-%EA%B2%B0%EC%A0%95"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1 디스크 형식 결정</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EB%94%94%EC%8A%A4%ED%81%AC-%ED%95%B8%EB%93%A4-%EA%B0%80%EC%A0%B8-%EC%98%A4%EA%B8%B0"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">4.1.2 드라이브 디스크 핸들 가져 오기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-USN-%EB%A1%9C%EA%B7%B8-%EC%B4%88%EA%B8%B0%ED%99%94"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">4.1.3 USN 로그 초기화</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-USN-%EB%A1%9C%EA%B7%B8-%EC%A0%95%EB%B3%B4-%EC%96%BB%EA%B8%B0"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">4.1.4 USN 로그 정보 얻기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5-USN-%EC%A0%80%EB%84%90-%ED%8C%8C%EC%9D%BC-%EC%A0%95%EB%B3%B4-%EC%96%BB%EA%B8%B0"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">4.1.5 USN 저널 파일 정보 얻기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-6-USN-%EB%A1%9C%EA%B7%B8-%ED%8C%8C%EC%9D%BC-%EC%82%AD%EC%A0%9C"><span class="nav-number">1.4.1.6.</span> <span class="nav-text">4.1.6 USN 로그 파일 삭제</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-7-%EB%AA%A8%EB%93%A0-%ED%8C%8C%EC%9D%BC-%EC%97%B4%EA%B1%B0-%EA%B2%B0%EA%B3%BC"><span class="nav-number">1.4.1.7.</span> <span class="nav-text">4.1.7 모든 파일 열거 결과</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%EA%B2%80%EC%83%89-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%91%EC%84%B1"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 검색 데이터 작성</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%EA%B5%AC%EC%84%B1-%EB%B2%A1%ED%84%B0"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">4.2.1 구성 벡터</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%A7%8C%EB%93%A4%EA%B8%B0"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">4.2.2 해시 테이블 만들기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%BD%EC%9E%85"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">4.2.3 데이터 삽입 :</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 인터페이스</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-KISS-%EC%9B%90%EB%A6%AC"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">4.3.1 KISS 원리</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%EA%B8%B0%EB%8A%A5"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">4.3.2 기능</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B2%B0%ED%95%A9"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 스레드 결합</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A5%BC-%EA%B2%B0%ED%95%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">4.4.1 스레드를 결합하는 이유</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-MFC%EC%97%90%EC%84%9C-%EC%9E%91%EC%97%85%EC%9E%90-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%8B%9C%EC%9E%91"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">4.4.2 MFC에서 작업자 스레드 시작</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%EC%95%8C%EB%A6%BC-%EC%98%81%EC%97%AD%EC%9C%BC%EB%A1%9C-%EC%B5%9C%EC%86%8C%ED%99%94"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">4.4.3 알림 영역으로 최소화</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%EC%B0%BE%EA%B8%B0"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 찾기</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-%EC%99%80%EC%9D%BC%EB%93%9C-%EC%B9%B4%EB%93%9C"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">4.5.1 와일드 카드</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-%EC%BC%80%EC%9D%B4%EC%8A%A4-%EC%A3%BC%EB%AC%B8"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">4.5.2 케이스, 주문</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B0%9C%EC%9D%B8-%EC%A0%95%EB%B3%B4-%EB%B0%8F-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B2%BD%EB%A1%9C"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">4.5.3 사용자 개인 정보 및 시스템 경로</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-4-%EA%B5%AC%ED%98%84"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">4.5.4 구현</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-5-%EA%B2%BD%EB%A1%9C-%EC%B6%9C%EB%A0%A5"><span class="nav-number">1.4.5.5.</span> <span class="nav-text">4.5.5 경로 출력</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%EB%B3%B5%EC%9E%A1%EC%84%B1-%EB%B6%84%EC%84%9D"><span class="nav-number">1.5.</span> <span class="nav-text">5 복잡성 분석</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EC%84%B1"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 시간 복잡성</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%EA%B3%B5%EA%B0%84-%EB%B3%B5%EC%9E%A1%EC%84%B1"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 공간 복잡성</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D"><span class="nav-number">1.6.</span> <span class="nav-text">6 문제 발생</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-USN-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EC%B4%88%EA%B8%B0%ED%99%94-%ED%95%A0-%EC%88%98-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1 USN 파일을 초기화 할 수 없습니다.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%EC%9C%A0%EB%8B%88-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-wchar%EC%99%80-char%EC%9D%98-%EB%AC%B8%EC%A0%9C"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2 유니 코드에서 wchar와 char의 문제</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-ifdef-%EC%9C%84%EC%B9%98-%EB%AC%B8%EC%A0%9C"><span class="nav-number">1.6.3.</span> <span class="nav-text">6.3 #ifdef 위치 문제</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%EB%A7%A4%EA%B0%9C-%EB%B3%80%EC%88%98-%EC%A0%84%EC%86%A1"><span class="nav-number">1.6.4.</span> <span class="nav-text">6.4 매개 변수 전송</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%EA%B0%80%EC%A7%80-%EC%9E%91%EC%9D%80-%EC%B5%9C%EC%A0%81%ED%99%94"><span class="nav-number">1.7.</span> <span class="nav-text">7 가지 작은 최적화</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%EC%9D%BD%EA%B8%B0-%EC%86%8D%EB%8F%84"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1 읽기 속도</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%ED%8C%8C%EC%9D%BC-%EC%97%B4%EA%B8%B0-%EB%B0%A9%EB%B2%95"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2 파일 열기 방법</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%EC%A7%84%ED%96%89%EB%A5%A0-%ED%91%9C%EC%8B%9C-%EC%A4%84"><span class="nav-number">1.7.3.</span> <span class="nav-text">7.3 진행률 표시 줄</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%EA%B2%B0%EB%A1%A0"><span class="nav-number">2.</span> <span class="nav-text">8 결론</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%EC%B0%B8%EC%A1%B0"><span class="nav-number">3.</span> <span class="nav-text">참조</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%EC%98%81%EC%96%B4-%EC%9A%94%EC%95%BD"><span class="nav-number">4.</span> <span class="nav-text">영어 요약</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LeiHao</p>
  <div class="site-description" itemprop="description">😃😃😃</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/ko/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/ko/tags/">
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">태그</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/leihao0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;leihao0" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/leihao0" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;leihao0" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/leihao0" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;leihao0" rel="noopener" target="_blank"><i class="fab fa-linkedin-in fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" class="cc-opacity" rel="noopener" target="_blank"><img src="/ko/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://leihao0.github.io/ko/QSearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/ko/images/avatar.gif">
      <meta itemprop="name" content="LeiHao">
      <meta itemprop="description" content="😃😃😃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeiHao's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          모든 것의 원리 추측과 실현
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>

      <time title="Post created: 2012-05-26 22:44:42" itemprop="dateCreated datePublished" datetime="2012-05-26T22:44:42+08:00">2012-05-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Updated at: 2020-12-21 07:53:08" itemprop="dateModified" datetime="2020-12-21T07:53:08+08:00">2020-12-21</time>
      </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/ko/QSearch/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="QSearch/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>13 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>연구 내용 </p>
<ol>
<li>NTFS MFT 읽기 </li>
<li>해시 테이블 구성 </li>
<li>파일의 시스템 경로 </li>
<li>GUI 및 작업자 스레드 </li>
<li>여러 검색 방법 </li>
<li>MFC 인터페이스 </li>
</ol>
<p>연구 계획 </p>
<ul>
<li>연구 방향 결정을위한 4 월 초 ~ 4 월 중순 </li>
<li>4 월 말부터 4 월 말까지 지식 포인트 별 준비, 간단한 시험 </li>
<li>5 월 초 프로그램 설계 및 개발 디버깅 및 운영 </li>
<li>5 월 중순 5 월 말 졸업 디자인 논문 작성 </li>
</ul>
<p>기능 및 혁신 </p>
<ol>
<li>CPU 및 메모리 사용량이 합리적인 범위 내에 있습니다. </li>
<li>소프트웨어가 안정적이며 다양한 검색 옵션을 제공합니다. </li>
<li>윈도우 검색 기능에 비해 파일 위치 속도가 매우 빠름 </li>
</ol>
<h1 id="NTFS-디스크-파일의-빠른-위치"><a href="#NTFS-디스크-파일의-빠른-위치" class="headerlink" title="NTFS 디스크 파일의 빠른 위치"></a>NTFS 디스크 파일의 빠른 위치</h1><p><strong>요약</strong> </p>
<blockquote>
<p>이 기사에서는 Windows NTFS 디스크 형식으로 하드 디스크에있는 모든 파일 및 폴더의 이름을 열거하고 C ++의 STL을 사용하여 해시 테이블, MFC의 GUI 및 작업자 스레드를 구성하고 마지막으로 사용자가 입력 한 키워드를 기반으로 구현을 실현하는 방법을 소개합니다. Google 키워드 검색처럼 간단하게 검색 한 다음 일치하는 모든 파일 / 폴더를 즉시 반환하고 파일 / 폴더의 시스템 경로를 재귀 적으로 가져옵니다. </p>
</blockquote>
<p>** 키워드 ** : ** NTFS, fast, 키워드, 검색, 파일 경로 ** </p>
<h2 id="1-소개"><a href="#1-소개" class="headerlink" title="1. 소개"></a>1. 소개</h2><p>Windows의 디렉터리 구조입니다. NTFS 볼륨에서 파일은<br>B + 트리 형태로 정렬, 디렉토리에서 파일 검색시 누르기<br>B + 트리 검색 방법은 먼저 루트 노드 (루트 디렉터리에서 시작)를 검색 한 다음 찾을 파일 이름을 루트 노드의 하위 노드에 해당하는 파일 이름과 비교하여 검색 할 저장 영역에 해당하는 하위 노드를 확인한 다음 자식 노드를 현재 루트 노드로 사용하고 파일을 찾을 때까지 다시 검색합니다. ^ [1] ^ </p>
<p>Microsoft 시스템에서 제공하는 검색은 텍스트 콘텐츠를 검색 할 수 있지만 속도는 매우 만족스럽지 않습니다. 대부분의 경우 파일이 저장된 컴퓨터의 폴더를 알고 싶을 뿐이며이 프로그램은이 문제를 매우 잘 해결합니다. </p>
<h2 id="2-NTFS에-대한-간략한-소개"><a href="#2-NTFS에-대한-간략한-소개" class="headerlink" title="2 NTFS에 대한 간략한 소개"></a>2 NTFS에 대한 간략한 소개</h2><h3 id="2-1-NTFS"><a href="#2-1-NTFS" class="headerlink" title="2.1 NTFS"></a>2.1 NTFS</h3><p>NTFS (신기술 파일 시스템) : Windows<br>NT 및 이후 Windows의 표준 파일 시스템. NTFS는 파일 할당 테이블 (FAT) 파일 시스템을 대체하고 Microsoft의 Windows 시리즈 운영 체제를위한 파일 시스템을 제공합니다. NTFS는 FAT 및 HPFS (고성능 파일 시스템)에 몇 가지 개선 사항을 적용했습니다. 예를 들어 메타 데이터를 지원하고 고급 데이터 구조를 사용하여 성능, 안정성 및 디스크 공간 활용도를 향상시킵니다. ^ [2] ^ </p>
<h3 id="2-2-현재-상황"><a href="#2-2-현재-상황" class="headerlink" title="2.2 현재 상황"></a>2.2 현재 상황</h3><p>NT 기반 Windows 사용<br>2000 / XP의 인기로 인해 많은 개별 사용자가 NTFS를 사용하기 시작했습니다. NTFS는 또한 클러스터를 하나의 단위로 사용하여 데이터 파일을 저장하지만 NTFS의 클러스터 크기는 디스크 또는 파티션 크기에 의존하지 않습니다. 클러스터 크기를 줄이면 디스크 공간 낭비가 줄어들뿐만 아니라 디스크 조각화 가능성도 줄어 듭니다. NTFS는 파일 암호화 관리 기능을 지원하여 사용자에게 더 높은 수준의 보안을 제공 할 수 있습니다. ^ [3] ^ </p>
<h2 id="3-준비"><a href="#3-준비" class="headerlink" title="3 준비"></a>3 준비</h2><h3 id="3-1-디자인-아이디어"><a href="#3-1-디자인-아이디어" class="headerlink" title="3.1 디자인 아이디어"></a>3.1 디자인 아이디어</h3><p>디스크의 모든 파일 이름을 데이터로 읽고 사용자가 입력 한 키워드에 따라 데이터를 일치시킵니다. 파일을 쉽게 열 수 있도록 경로와 함께 올바른 경로가 사용자에게 반환됩니다. </p>
<p>구체적인 디자인 아이디어는 그림 3-1에 나와 있습니다. </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_00.jpg">그림 3-1 디자인 아이디어</a> </p>
<p>해시 테이블의 가장 큰 장점은 거의 일정한 시간으로 간주 될 수있는 데이터 저장 및 검색에 소요되는 시간을 크게 줄여 준다는 것입니다. 비용은 더 많은 메모리를 사용하는 것입니다. 그러나 사용 가능한 메모리가 점점 더 많아지면서 시간과 공간을 교환하는 것이 좋습니다. 또한 코딩의 용이성도 특징 중 하나입니다. </p>
<h3 id="3-2-USN이란"><a href="#3-2-USN이란" class="headerlink" title="3.2 USN이란?"></a>3.2 USN이란?</h3><p>프로그램의 최우선 순위는 USN을 읽는 것입니다. </p>
<p>USN 是 업데이트 서비스 번호 저널 또는 변경<br>NTFS 볼륨에 수정 된 정보를 기록하는 기능인 Journal의 약어는 파티션에서 모니터링 할 파일 및 디렉터리의 수를 설정하고 모니터링되는 개체의 수정 시간과 내용을 기록 할 수 있습니다. </p>
<p>USN 로그가 활성화되면 각 NTFS 볼륨에 대해 파일 추가, 삭제 및 수정에 대한 정보가있을 때 NTFS는 USN 로그를 사용하여 다음과 같이 기록하고 저장합니다.<br>USN_RECORD의 형식입니다. </p>
<h3 id="3-3-빠른-이유"><a href="#3-3-빠른-이유" class="headerlink" title="3.3 빠른 이유"></a>3.3 빠른 이유</h3><p>USN 로그는 WORD 디렉터리와 동일하며 색인을 제공합니다. 물론 기사의 내용이 변경되면 USN 로그는 수정 시점을 기록하지만 수정 내용은 기록하지 않으므로 색인 파일이 매우 작습니다. 기사의 특정 단락을 찾으려면 마우스 휠을 크게 돌릴 필요없이 목차를 직접보고 Ctrl + 마우스 클릭 만 누르면 위치를 찾을 수 있습니다. </p>
<p>같은 방식으로 특정 파일을 찾고자 할 때 USN 로그 (즉, 설정된 인덱스)를 검색하여 파일이 존재하는지 직접 확인할 수 있습니다. </p>
<p>추신 : 비록 윈도우가 “모든 것이 파일”은 아니지만 (유닉스 / 리눅스<br>)의 기본 철학 중 하나이지만 폴더도 파일 형태로 존재하므로 USN을 통해 위치를 찾을 수도 있습니다. </p>
<h3 id="3-4-환경"><a href="#3-4-환경" class="headerlink" title="3.4 환경"></a>3.4 환경</h3><p>NTFS 형식은 원래 Microsoft의 특허이므로 편리한 액세스를 위해 일련의 API 기능이 제공됩니다. </p>
<p>오래되었지만 고전적인 Visual C ++ 6.0<br>프로그래밍 도구 였지만 당시에는 NTFS 형식이 없었기 때문에 VC2005가 통합 개발 환경으로 선택되었으며 2000 년 이후 Windows 시스템에서만 실행할 수 있습니다. </p>
<h2 id="4-프로그램-실행"><a href="#4-프로그램-실행" class="headerlink" title="4 프로그램 실행"></a>4 프로그램 실행</h2><h3 id="4-1-USN-읽기"><a href="#4-1-USN-읽기" class="headerlink" title="4.1 USN 읽기"></a>4.1 USN 읽기</h3><p>다음은<code>&lt;Winioctl.h&gt;</code>헤더 파일에 포함 된 Microsoft ^ [4] ^에서 제공하는 모든 API 함수입니다. </p>
<h4 id="4-1-1-디스크-형식-결정"><a href="#4-1-1-디스크-형식-결정" class="headerlink" title="4.1.1 디스크 형식 결정"></a>4.1.1 디스크 형식 결정</h4><p>NTFS 형식의 디스크를 찾으려면 다음 함수를 호출하십시오. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GetVolumeInformation(</span><br><span class="line">	lpRootPathName: PChar;               <span class="comment">// 磁盘驱动器代码字符串</span></span><br><span class="line">	lpVolumeNameBuffer: PChar;           <span class="comment">// 磁盘驱动器卷标名称</span></span><br><span class="line">	nVolumeNameSize: DWORD;              <span class="comment">// 磁盘驱动器卷标名称长度</span></span><br><span class="line">	lpVolumeSerialNumber: PDWORD;        <span class="comment">// 磁盘驱动器卷标序列号</span></span><br><span class="line">	var lpMaximumComponentLength: DWORD; <span class="comment">// 系统允许的最大文件名长度</span></span><br><span class="line">    var lpFileSystemFlags: DWORD;        <span class="comment">// 文件系统标识</span></span><br><span class="line">	lpFileSystemNameBuffer: PChar;       <span class="comment">// 格式类型</span></span><br><span class="line">	nFileSystemNameSize: DWORD           <span class="comment">// 文件操作系统名称长度</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>우리가 원하는 lpFileSystemNameBuffer는 “FAT32”, “NTFS”및 기타 문자열을 반환합니다. </p>
<p>그런 다음 루프를 사용하여 NTFS 형식의 A-Z 드라이브 문자를 계산 한 다음 초기화 </p>
<h4 id="4-1-2-드라이브-디스크-핸들-가져-오기"><a href="#4-1-2-드라이브-디스크-핸들-가져-오기" class="headerlink" title="4.1.2 드라이브 디스크 핸들 가져 오기"></a>4.1.2 드라이브 디스크 핸들 가져 오기</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hVol = CreateFile(</span><br><span class="line">	<span class="string">&quot;盘符字符串&quot;</span>,  <span class="comment">// 必须如\.\C: (A-Z)的形式</span></span><br><span class="line">	GENERIC_READ | GENERIC_WRITE, <span class="comment">// 可以为</span></span><br><span class="line">	FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="comment">// 必须包含有FILE_SHARE_WRITE</span></span><br><span class="line">	<span class="literal">NULL</span>, <span class="comment">// 这里不需要</span></span><br><span class="line">	OPEN_EXISTING, <span class="comment">// 必须包含OPEN_EXISTING, CREATE_ALWAYS可能会导致错误</span></span><br><span class="line">	FILE_ATTRIBUTE_READONLY, <span class="comment">// FILE_ATTRIBUTE_NORMAL可能会导致错误</span></span><br><span class="line">	<span class="literal">NULL</span>); <span class="comment">// 这里不需要</span></span><br></pre></td></tr></table></figure>

<p>참고 사항 : </p>
<ol>
<li>CreateFile은 아래에서 사용되는 핸들을 반환합니다. </li>
<li>드라이브 문자는<code>\\. \ C :</code>형식이어야하므로<code>C ++</code>언어에서 백 슬래시 “//“는 “/“를 나타냅니다. </li>
<li>관리자 권한이 필요합니다 (vista, UAC는 win7에서 팝업 됨). </li>
</ol>
<p><code>hVol! = INVALID_HANDLE_VALUE</code>이면 핸들을 성공적으로 획득했음을 의미하며 다음 단계를 계속할 수 있습니다. </p>
<h4 id="4-1-3-USN-로그-초기화"><a href="#4-1-3-USN-로그-초기화" class="headerlink" title="4.1.3 USN 로그 초기화"></a>4.1.3 USN 로그 초기화</h4><p><code>DeviceIoControl</code>의 제어 코드로<code>FSCTL_CREATE_USN_JOURNAL</code>을 사용하십시오. </p>
<p><code>Cujd</code>는<code>CREATE_USN_JOURNAL_DATA</code> 구조를 가리키는 입력 버퍼에 대한 포인터입니다. </p>
<h4 id="4-1-4-USN-로그-정보-얻기"><a href="#4-1-4-USN-로그-정보-얻기" class="headerlink" title="4.1.4 USN 로그 정보 얻기"></a>4.1.4 USN 로그 정보 얻기</h4><p><code>DeviceIoControl</code>의 제어 코드로<code>FSCTL_QUERY_USN_JOURNAL</code>을 사용하십시오. </p>
<p><code>lpOutBuffer</code>는 구조체 인<code>USN_JOURNAL_DATA</code>를 반환합니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    DWORDLONG UsnJournalID;</span><br><span class="line">    USN       FirstUsn;</span><br><span class="line">    USN       NextUsn;</span><br><span class="line">    USN       LowestValidUsn;</span><br><span class="line">    USN       MaxUsn;</span><br><span class="line">    DWORDLONG MaximumSize;</span><br><span class="line">    DWORDLONG AllocationDelta;</span><br><span class="line">&#125; USN_JOURNAL_DATA, *PUSN_JOURNAL_DATA;</span><br></pre></td></tr></table></figure>

<p><code>UsnJournalID</code>,<code>FirstUsn</code>,<code>NextUsn</code>은 다음 단계에서 사용됩니다. </p>
<h4 id="4-1-5-USN-저널-파일-정보-얻기"><a href="#4-1-5-USN-저널-파일-정보-얻기" class="headerlink" title="4.1.5 USN 저널 파일 정보 얻기"></a>4.1.5 USN 저널 파일 정보 얻기</h4><p><code>USN</code>은<code>USN_RECORD</code> 형식으로 저장되므로 구조는 다음과 같습니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	DWORD RecordLength; <span class="comment">// 记录长度</span></span><br><span class="line">	WORD MajorVersion; <span class="comment">// 主版本</span></span><br><span class="line">	WORD MinorVersion; <span class="comment">// 次版本</span></span><br><span class="line">	DWORDLONG FileReferenceNumber; <span class="comment">// 文件引用数</span></span><br><span class="line">	DWORDLONG ParentFileReferenceNumber; <span class="comment">// 父目录引用数</span></span><br><span class="line">	USN Usn; <span class="comment">// USN</span></span><br><span class="line">	LARGE_INTEGER TimeStamp; <span class="comment">// 时间戳</span></span><br><span class="line">	DWORD Reason; <span class="comment">// 原因</span></span><br><span class="line">	DWORD SourceInfo; <span class="comment">// 源信息</span></span><br><span class="line">	DWORD SecurityId; <span class="comment">// 安全</span></span><br><span class="line">	ID DWORD FileAttributes; <span class="comment">// 文件属性</span></span><br><span class="line">	WORD FileNameLength; <span class="comment">// 文件长度</span></span><br><span class="line">	WORD FileNameOffset; <span class="comment">// 文件名偏移</span></span><br><span class="line">	DWORD ExtraInfo1;</span><br><span class="line">	DWORD ExtraInfo2; DWORD ExtraInfo3; <span class="comment">// Hypothetically added in version 2.3</span></span><br><span class="line">	WCHAR FileName[<span class="number">1</span>]; <span class="comment">// 文件名第一位的指针</span></span><br><span class="line">&#125; USN_RECORD, *PUSN_RECORD;</span><br></pre></td></tr></table></figure>

<p><code>FileReferenceNumber</code>,<code>ParentFileReferenceNumber</code>,<code>FileNameLength</code>,<code>FileName</code>을 확인합니다. </p>
<p>이 변수는 매우 중요합니다 </p>
<p><code>DeviceIoControl ()</code>은<code>FSCTL_ENUM_USN_DATA</code>와 협력합니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">0</span>!=DeviceIoControl(hVol,</span><br><span class="line">	 	FSCTL_ENUM_USN_DATA,</span><br><span class="line">	 	&amp;med,</span><br><span class="line">	 	<span class="keyword">sizeof</span> (med),</span><br><span class="line">	 	Buffer,</span><br><span class="line">	 	BUF_LEN,</span><br><span class="line">	 	&amp;usnDataSize,</span><br><span class="line">	 	<span class="literal">NULL</span>)) &#123;</span><br><span class="line"></span><br><span class="line">	 	DWORD dwRetBytes = usnDataSize - <span class="keyword">sizeof</span> (USN);</span><br><span class="line">	 	<span class="comment">// 找到第一个 USN 记录</span></span><br><span class="line">	 	UsnRecord = (PUSN_RECORD)(((PCHAR)Buffer)+<span class="keyword">sizeof</span> (USN));</span><br><span class="line"></span><br><span class="line">	 	<span class="keyword">while</span> (dwRetBytes&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">	 		<span class="comment">// 获取到的信息</span></span><br><span class="line">	 		<span class="function">CString <span class="title">CfileName</span><span class="params">(UsnRecord-&gt;FileName, UsnRecord-&gt;FileNameLength/<span class="number">2</span>)</span></span>;</span><br><span class="line">	 		pfrnName.filename = nameCur.filename = CfileName;</span><br><span class="line">	 		pfrnName.pfrn = nameCur.pfrn = UsnRecord-&gt;ParentFileReferenceNumber;</span><br><span class="line"></span><br><span class="line">	 		<span class="comment">// Vector</span></span><br><span class="line">	 		VecNameCur.push_back(nameCur);</span><br><span class="line"></span><br><span class="line">	 		<span class="comment">// 构建hash...</span></span><br><span class="line">	 		frnPfrnNameMap[UsnRecord-&gt;FileReferenceNumber] = pfrnName;</span><br><span class="line">	 		<span class="comment">// 获取下一个记录</span></span><br><span class="line">	 		DWORD recordLen = UsnRecord-&gt;RecordLength;</span><br><span class="line">	 		dwRetBytes -= recordLen;</span><br><span class="line">	 		UsnRecord = (PUSN_RECORD)(((PCHAR)UsnRecord)+recordLen);</span><br><span class="line"></span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="comment">// 获取下一页数据</span></span><br><span class="line">	 	med.StartFileReferenceNumber = \*(USN \*)&amp;Buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그중 ‘Med’는 다음과 같습니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MFT_ENUM_DATA med;</span><br><span class="line"></span><br><span class="line">med.StartFileReferenceNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">med.LowUsn = <span class="number">0</span>;<span class="comment">//UsnInfo.FirstUsn;</span></span><br></pre></td></tr></table></figure>

<p>여기에서 테스트 한 결과, ‘FirstUsn’의 사용이 때때로 부정확하여 데이터가 불완전한 경우 0을 직접 쓰는 것이 좋습니다. </p>
<p><code>med.HighUsn = UsnInfo.NextUsn;</code> </p>
<p>이 루프에서는 매번 얻은 파일 이름이 벡터 및 해시 테이블에 각각 삽입됩니다 (아래 설명). </p>
<h4 id="4-1-6-USN-로그-파일-삭제"><a href="#4-1-6-USN-로그-파일-삭제" class="headerlink" title="4.1.6 USN 로그 파일 삭제"></a>4.1.6 USN 로그 파일 삭제</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DeviceIoControl(hVol,</span><br><span class="line">	FSCTL_DELETE_USN_JOURNAL,</span><br><span class="line">	&amp;dujd,</span><br><span class="line">	<span class="keyword">sizeof</span> (dujd),</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	&amp;br,</span><br><span class="line">	<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-1-7-모든-파일-열거-결과"><a href="#4-1-7-모든-파일-열거-결과" class="headerlink" title="4.1.7 모든 파일 열거 결과"></a>4.1.7 모든 파일 열거 결과</h4><p>그림 4-1과 같이 분석을 위해 데이터를 Allfile.txt로 저장합니다. </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_01.jpg">图 4-1 Allfile.txt</a> </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_02.jpg">图 4-1 Allfile.txt</a> </p>
<p>컴퓨터의 D 드라이브를 테스트로 사용하고 모든 파일을 열거했습니다. 그림과 같이 약 40W의 파일, 총 100W 이상의 데이터가 있으며 파일 크기는 약 20MB입니다. 이것은 후속 프로그램이 차지하는 메모리 양에 대한 모호한 추정치이며 약 50M입니다. 1G의 메모리에 대해서도 합리적인 범위 내에 있습니다. 원본 데이터를 사용한 분석은 다음과 같습니다. </p>
<p>예를 들어 Linux programming practice.isz 파일의 시스템 경로는<code>D : \ Ghost \ Linux \ Linux programming practice.isz</code>입니다. 파일에서 결과를 확인하세요. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D:\</span><br><span class="line">Frn: 5000000000005</span><br><span class="line">Pfrn: NULL</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">Ghost</span><br><span class="line">Frn: 20000000000fd</span><br><span class="line">Pfrn: 5000000000005</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">Linux</span><br><span class="line">Frn: e0000000010d2</span><br><span class="line">Pfrn: 20000000000fd</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">Linux编程实践.isz</span><br><span class="line">Frn: 190000000003b2</span><br><span class="line">Pfrn: e0000000010d2</span><br><span class="line">可以得出：</span><br><span class="line">Linux编程实践.isz-&gt;Pfrn &#x3D;&#x3D; Linux-&gt;Frn</span><br><span class="line">Linux-&gt;Pfrn &#x3D;&#x3D; Ghost-&gt;Frn</span><br><span class="line">Ghost-&gt;Pfrn &#x3D;&#x3D; D:\ -&gt; Frn</span><br><span class="line">D:\ -&gt; Pfrn 停止</span><br></pre></td></tr></table></figure>

<p>따라서 재귀 함수 (직간접 적으로 자체 함수 호출)를 사용하면 전체 경로를 얻을 수 있습니다. </p>
<h3 id="4-2-검색-데이터-작성"><a href="#4-2-검색-데이터-작성" class="headerlink" title="4.2 검색 데이터 작성"></a>4.2 검색 데이터 작성</h3><h4 id="4-2-1-구성-벡터"><a href="#4-2-1-구성-벡터" class="headerlink" title="4.2.1 구성 벡터"></a>4.2.1 구성 벡터</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">name_cur</span> &#123;</span></span><br><span class="line">    CString filename;</span><br><span class="line">    DWORDLONG pfrn;</span><br><span class="line">&#125;Name_Cur;</span><br></pre></td></tr></table></figure>

<p>벡터: </p>
<p>순차 컨테이너. 벡터의 요소는 위치 인덱스를 통해 액세스됩니다. push_back 또는<br>insert 함수는 벡터에 요소를 추가합니다. 벡터에서<br>컨테이너에 요소를 추가하면 컨테이너의 메모리 공간이 다시 할당 될 수 있으며 모든 반복기가 무효화 될 수도 있습니다. 에<br>벡터<br>컨테이너 중간에 요소를 추가 (또는 삭제)하면 삽입 (또는 삭제) 지점 이후의 요소를 가리키는 모든 반복기가 무효화됩니다. </p>
<p>벡터를 사용하여 &lt;파일 이름, 현재 디렉터리&gt;를 저장합니다. 퍼지 검색의 요구 사항으로 인해 이진 검색과 같은 빠른 검색 방법은 여기에 적용 할 수 없으며 Vector의 처음부터 끝까지 선형 순회 방법이이 요구 사항을 충족합니다. . </p>
<h4 id="4-2-2-해시-테이블-만들기"><a href="#4-2-2-해시-테이블-만들기" class="headerlink" title="4.2.2 해시 테이블 만들기"></a>4.2.2 해시 테이블 만들기</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pfrn_name</span> &#123;</span></span><br><span class="line">    DWORDLONG pfrn;</span><br><span class="line">    CString filename;</span><br><span class="line">&#125;Pfrn_Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;DWORDLONG, Pfrn_Name&gt; Frn_Pfrn_Name_Map;</span><br></pre></td></tr></table></figure>

<p>여기서는 STL에서 제공하는 맵 라이브러리 함수 ^ [5] ^를 사용합니다. map은 키-값 쌍의 모음입니다. 지도<br>유형은 일반적으로 연관 배열 (연관<br>배열) : 내장 배열 유형과 마찬가지로 키를 첨자로 사용하여 값을 가져올 수 있습니다. 연관성의 본질은 요소의 값이 배열에서 요소의 위치에 의해 획득되는 것이 아니라 특정 키와 연관된다는 것입니다. </p>
<ol>
<li>해시 함수를 직접 구현하는 경우 진행 상황에 영향을 미치는 몇 가지 버그가있을 수 있으므로 STL에서 제공하는 안정적인 맵을 사용하여 구현하는 것이 좋습니다. </li>
<li>“바퀴를 재발 명하지 마십시오”바퀴를 재발 명하지 마십시오 ^ [6] ^ <ol>
<li>예를 들어 Google의 Android는 Google이 시스템 커널 만 개발할 수 없는데 매우 성숙한 Linux 커널을 사용합니까? Google과 같은 거대 기업이 이러한 능력 없이는 불가능하다고 생각합니다. 대신 바퀴를 재발 명하지 않는 원칙을 존중합니다. </li>
</ol>
</li>
</ol>
<h4 id="4-2-3-데이터-삽입"><a href="#4-2-3-데이터-삽입" class="headerlink" title="4.2.3 데이터 삽입 :"></a>4.2.3 데이터 삽입 :</h4><p>이것은 섹션 4.1.5, Get USN Journal에서 사용됩니다.<br>파일 정보의 루프에서 매번 획득 한<code>USN_RECORD</code> 정보,<code>filename</code>,<br><code>pfrn</code>,<code>frn</code>이 각각 벡터 테이블과 해시 테이블에 삽입됩니다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pfrnName.filename &#x3D; nameCur.filename &#x3D; CfileName;</span><br><span class="line">pfrnName.pfrn &#x3D; nameCur.pfrn &#x3D; UsnRecord-&gt;ParentFileReferenceNumber;</span><br><span class="line">VecNameCur.push_back(nameCur);</span><br><span class="line">frnPfrnNameMap[UsnRecord-&gt;FileReferenceNumber] &#x3D; pfrnName;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-인터페이스"><a href="#4-3-인터페이스" class="headerlink" title="4.3 인터페이스"></a>4.3 인터페이스</h3><p>프로젝트를 시작할 때 VC2005는 명령 줄 (콘솔) 프로젝트와 GUI 프로젝트를 제공합니다. 명령 줄 프로그래밍은 매우 편리하고 빠르며 실용적이며 비교적 간단합니다. 콘솔이 요구 사항을 충족 할 수 있으면 인터페이스가 필요하지 않습니다. 또는 때때로 대상 플랫폼이 그래픽 사용자 인터페이스를 표시 할 수 없습니다. 그러나,<br>GUI에는 메뉴 시스템 및 더 나은 상호 작용과 같은 더 분명한 이점이 있습니다. 또한 메뉴 선택 및 필드 간 데이터 이동 과정에서<br>마우스는 매우 유용하며 GUI는 갈 길입니다. 따라서 프로그램을 작성할 때 먼저 콘솔에서 중간 데이터를 실험 한 다음 문제없이 GUI 인터페이스로 전환했습니다. </p>
<p>MFC : MFC라고도하는 Microsoft Foundation Classes<br>, Microsoft의<br>“프로그램 디자인, 지루함, 지루함 및 어려움”이 만든 가장 큰 공헌. MFC<br>대화 상자 생성을 매우 간단하게 만듭니다. 또한 메시지 전달 시스템 (메시지<br>파견), WPARAM 및 LP ARAM의 쉬운 실수를 처리합니다. MFC<br>일부 사람들을 C ++로 유인하는 원동력이기도합니다.<br>이 프로그램은 그림 4-2와 같이 Microsoft에서 제공하는 MFC에 의해 구현됩니다. </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_04.jpg">그림 4-2 MFC 인터페이스</a> </p>
<h4 id="4-3-1-KISS-원리"><a href="#4-3-1-KISS-원리" class="headerlink" title="4.3.1 KISS 원리"></a>4.3.1 KISS 원리</h4><p>KISS 원칙은 “Keep It Sample And<br>“Stupid”의 약어, 단순성 및 조작 용이성은 디자인의 가장 중요한 원칙입니다. </p>
<p>KISS 원칙은 아마도 디자인, 주택 개선 디자인, 인터페이스 디자인에서 가장 존경받는 것입니다.<br>운영 디자인 측면에서 복잡한 것들이 점점 더 대중화되고 단순한 것들이 점점 더 인식되고 있습니다. 예를 들어, 이러한 UI 디자인과 중국 웹 페이지는 부정적인 예입니다. “IKEA”(IKEA) 간단하고 효율적인 홈 디자인 및 생산 아이디어, “Microsoft”(Microsoft) “당신이 보는 것은 당신이 얻는 것”개념, “Google”(Google) 단순하고 직접적인 비즈니스 스타일, 예외없이 “키스”원칙. ^ [7] ^ </p>
<h4 id="4-3-2-기능"><a href="#4-3-2-기능" class="headerlink" title="4.3.2 기능"></a>4.3.2 기능</h4><p>키스 원칙에 따라 가능한 한 간결해야합니다. 편집 상자 버튼 목록 상자 추가<br>menu ^ [8] ^이 컨트롤의 기능은 다음과 같습니다. </p>
<ul>
<li>편집 상자 <ul>
<li>사용자가 검색해야하는 문자열을 가져옵니다. </li>
</ul>
</li>
<li>단추 <ol>
<li>EditBox에서 문자열 가져 오기 </li>
<li>캐릭터가 너무 짧아서 프롬프트를 표시 할 수 없습니다. </li>
<li>확대경 사진을 추가하면 기능이 한눈에 명확합니다 </li>
</ol>
</li>
<li>리스트 박스 <ol>
<li>일치하는 파일 이름과 경로를 표시하고 두 번 클릭하여 파일을 엽니 다. </li>
<li>경로가 비교적 길 수 있으므로 가로 스크롤 막대를 추가하십시오. </li>
<li>목록 상자에서 결과 파일 경로를 두 번 클릭하여 두 번 클릭 한 파일을 엽니 다. </li>
</ol>
</li>
<li>메뉴 <ul>
<li>메뉴, 케이스, 검색 순서 선택 가능 </li>
</ul>
</li>
</ul>
<h3 id="4-4-스레드-결합"><a href="#4-4-스레드-결합" class="headerlink" title="4.4 스레드 결합"></a>4.4 스레드 결합</h3><h4 id="4-4-1-스레드를-결합하는-이유"><a href="#4-4-1-스레드를-결합하는-이유" class="headerlink" title="4.4.1 스레드를 결합하는 이유"></a>4.4.1 스레드를 결합하는 이유</h4><p>스레드의 장점 : 스레드가 저렴합니다. 스레드가 더 빨리 시작되고 더 빨리 종료되며 시스템 리소스에 미치는 영향이 적습니다. </p>
<p>다음 사항도 고려하십시오. </p>
<ol>
<li>io의 제한으로 인해 여러 스레드를 사용하여 동일한 하드 디스크에서 동시에 MFT를 읽는 것은 의미가 없습니다. </li>
<li>동일한 하드 디스크의 다른 파티션에있는 MFT에 대한 디스크 액세스는 대신 속도에 영향을 줄 수 있습니다. 하드 디스크가 여러 개인 컴퓨터의 경우 효율성이 크게 향상되어야합니다. 그러나 여러 하드 드라이브의 사용자는 RAID 어레이를 구성 할 수 있습니다. 가장 좋은 해결책은 A-Z 디스크를 순차적으로 읽는 것입니다. </li>
<li>MFC가 처음 생성 될 때 순차적으로 실행 되었기 때문에 모든 데이터 통계가 완료된 후에 만 ​​인터페이스가 표시 될 수 있으며이 과정에서 사용자는 쉽게 인내심을 잃을 수 있습니다. </li>
<li>마지막으로 작업자 스레드 배경 통계 인 UI 스레드를 결정합니다. </li>
</ol>
<h4 id="4-4-2-MFC에서-작업자-스레드-시작"><a href="#4-4-2-MFC에서-작업자-스레드-시작" class="headerlink" title="4.4.2 MFC에서 작업자 스레드 시작"></a>4.4.2 MFC에서 작업자 스레드 시작</h4><p>MFC는 오랫동안 멀티 스레딩에 대한 지원을 추가했습니다. 일반적인 MFC에서<br>이 프로그램에서 멀티 스레딩 지원은 많은 놀라운 작업 뒤에 숨겨져 있습니다. MFC<br>멀티 스레딩과 관련된 특정 Win32 개념을 강화하려는 시도도 있습니다. </p>
<p>GUI 및 작업자 스레드는 모두 AfxBeginThread ()로 시작되지만 MFC는 C ++ 함수의 오버로딩 특성을 사용하여이 함수에 대해 두 가지 다른 선언을 제공합니다. 컴파일러는 제공 한 매개 변수에 따라 사용할 올바른 것을 자동으로 선택합니다. ^ [9] ^ </p>
<p>AfxBeginThread를 사용하여 스레드를 시작하십시오.<br>pParam 새 스레드로 전달하는 데 사용되는 4 바이트 값입니다. 정수, 포인터 또는 0 일 수 있습니다. </p>
<p>여기서는 처음 두 개의 매개 변수, 객체의 스레드 함수 및 객체 포인터 만 사용됩니다. </p>
<p>그림 4-3과 같이 작업 관리자에서 두 개의 스레드를 볼 수 있습니다. </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_03.jpg">그림 4-3 작업 관리자에 스레드 수 표시</a> </p>
<p>작업자 스레드가 작업을 완료하면 자동으로 종료되고 스레드로 돌아갑니다. </p>
<h4 id="4-4-3-알림-영역으로-최소화"><a href="#4-4-3-알림-영역으로-최소화" class="headerlink" title="4.4.3 알림 영역으로 최소화"></a>4.4.3 알림 영역으로 최소화</h4><p>이제 점점 더 많은 프로그램이 오른쪽 상단 모서리에서 닫기를 클릭합니다. 실제로 트레이 아이콘으로 최소화됩니다. 프로그램을 종료하려면 트레이 아이콘을 마우스 오른쪽 버튼으로 클릭하여 종료해야합니다. </p>
<p>프로그램을 종료하지 않고 최소화를 실현하여 편리하게 파일을 찾을 수 있습니다. </p>
<p>1) 작업 표시 줄의 표시를 최소화합니다. </p>
<p>2) 작업 표시 줄에 트레이 아이콘을 표시하지 않고 종료하려면 닫기를 클릭하고, 디스플레이 창에 응답하려면 두 번 클릭합니다. </p>
<p>3) 트레이 아이콘에 메뉴를 추가합니다. </p>
<h3 id="4-5-찾기"><a href="#4-5-찾기" class="headerlink" title="4.5 찾기"></a>4.5 찾기</h3><h4 id="4-5-1-와일드-카드"><a href="#4-5-1-와일드-카드" class="headerlink" title="4.5.1 와일드 카드"></a>4.5.1 와일드 카드</h4><p>실제 응용 프로그램에서는 test.2012-5-14.txt와 같이 파일 이름을 명확하게 기억할 수 없습니다.<br>.txt”이므로 퍼지 검색이 필요합니다. 콘솔에서 파일 이름은 &lt;filename,<br>pfrn&gt; 해시 테이블 생성 퍼지 검색을 구현하고자 할 경우 해시 테이블이 불필요 해지며 컨테이너 벡터를 직접 사용할 수 있습니다. </p>
<p>실제 상황에 따라 엄격한 와일드 카드가 필요하지 않습니다. “\ *?”<br>대부분의 검색 문제를 해결할 수 있으며 사용자는 일반적으로 정규식은 물론 와일드 카드의 사용을 알지 못할 수 있습니다. 그러니 “공백”으로 시작하세요<br>“\ *?”대신 Baidu를 구현하십시오.<br>공백으로 키워드를 구분하는 Google의 검색 방법은 좋은 솔루션입니다. \ * \ * \ * \ * </p>
<h4 id="4-5-2-케이스-주문"><a href="#4-5-2-케이스-주문" class="headerlink" title="4.5.2 케이스, 주문"></a>4.5.2 케이스, 주문</h4><p>일반적으로 다음 두 가지 상황이 있습니다. </p>
<ol>
<li>사용자는 파일 이름 또는 경로의 대소 문자를 기억하지 못할 수 있습니다. </li>
<li>때로는 너무 많은 파일이 있으며 올바른 파일을 필터링하기 위해 엄격한 대문자 사용이 필요할 수 있습니다. </li>
<li>키워드 순서가 기억 나지 않습니다. </li>
</ol>
<p>따라서 다음 두 가지 옵션을 제공하십시오. </p>
<ol>
<li>엄격한 경우 </li>
<li>주문 없음 </li>
</ol>
<p>일반적인 상황에 따라 기본값은 대소 문자를 구분하지 않는 순차 검색입니다. </p>
<h4 id="4-5-3-사용자-개인-정보-및-시스템-경로"><a href="#4-5-3-사용자-개인-정보-및-시스템-경로" class="headerlink" title="4.5.3 사용자 개인 정보 및 시스템 경로"></a>4.5.3 사용자 개인 정보 및 시스템 경로</h4><ol>
<li>일부 폴더는 사용자의 개인 파일을 저장하는 데 사용됩니다. </li>
<li>시스템 폴더, 예 :<code>c : \ windows \ *</code>일반 사용자는 사용하지 않으며 동일한 검색은 불필요한 파일을 증가시키고 시스템에 부담을줍니다. </li>
</ol>
<p>따라서 그림 4-4와 같이 폴더 제외 옵션을 추가해야합니다. </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_06.jpg">그림 4-4 폴더 제외 인터페이스</a> </p>
<p>해당 기능은 다음과 같습니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIgnore</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;\* pignorelist )</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> tmp = CW2A(path);</span><br><span class="line">	<span class="keyword">for</span> ( <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it = pignorelist-&gt;begin();</span><br><span class="line">		it != pignorelist-&gt;end(); ++it ) &#123;</span><br><span class="line">			<span class="keyword">size_t</span> i = it-&gt;length();</span><br><span class="line">			<span class="keyword">if</span> ( !tmp.compare(<span class="number">0</span>, i, \*it,<span class="number">0</span>, i) ) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-4-구현"><a href="#4-5-4-구현" class="headerlink" title="4.5.4 구현"></a>4.5.4 구현</h4><p>새로운 일치하는 문자열 클래스 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cmpStrStr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	cmpStrStr(<span class="keyword">bool</span> uplow, <span class="keyword">bool</span> inorder) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;uplow = uplow;</span><br><span class="line">		<span class="keyword">this</span>-&gt;isOrder = inorder;</span><br><span class="line">	&#125;</span><br><span class="line">	~cmpStrStr() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">cmpStrFilename</span><span class="params">(CString str, CString filename)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">infilename</span><span class="params">(CString &amp;strtmp, CString &amp;filenametmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">bool</span> uplow;</span><br><span class="line">	<span class="keyword">bool</span> isOrder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>** 4.2.1 **에서 VecNameCur를 탐색하고 cmpStrFilename 일치 함수를 전달하고 일치하는 파일 이름을 가져옵니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="built_in">vector</span>&lt;Name_Cur&gt;::const_iterator cit = VecNameCur.begin();</span><br><span class="line">	cit != VecNameCur.end(); ++cit) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( cmpstrstr.cmpStrFilename(str, cit-&gt;filename) ) &#123;</span><br><span class="line">		path.Empty();</span><br><span class="line">		<span class="comment">// 还原 路径</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// vol:\  path \ cit-&gt;filename</span></span><br><span class="line">		getPath(cit-&gt;pfrn, path);</span><br><span class="line">		path += cit-&gt;filename;</span><br><span class="line">		<span class="comment">// path已是全路径</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( isIgnore(pignorelist) ) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rightFile.push_back(path);</span><br><span class="line">		<span class="comment">//path.Empty();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmpStrFilename函数：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> end = str.GetLength();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( pos &lt; end ) &#123;</span><br><span class="line">	<span class="comment">// 对于str，取得 每个空格分开为的关键词</span></span><br><span class="line">	pos = str.Find( _T(<span class="string">&#x27; &#x27;</span>) );</span><br><span class="line"></span><br><span class="line">	CString strtmp;</span><br><span class="line">	<span class="keyword">if</span> ( pos == <span class="number">-1</span> ) &#123;</span><br><span class="line">		<span class="comment">// 无空格</span></span><br><span class="line">		strtmp = str;</span><br><span class="line">		pos = end;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		strtmp = str.Mid(<span class="number">0</span>, pos<span class="number">-0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( !infilename(strtmp, filename) ) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str.Delete(<span class="number">0</span>, pos);</span><br><span class="line">	str.TrimLeft(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>infilename 함수에서 문자열 일치 알고리즘을 쉽게 다시 작성하여 일부 확장을 얻을 수 있습니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CString <span class="title">filenametmp</span><span class="params">(filename)</span></span>;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( !uplow ) &#123;</span><br><span class="line">	<span class="comment">// 大小写敏感</span></span><br><span class="line">	filenametmp.MakeLower();</span><br><span class="line">	pos = filenametmp.Find(strtmp.MakeLower());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	pos = filenametmp.Find(strtmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="number">-1</span> == pos ) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( !isOrder ) &#123;</span><br><span class="line">	<span class="comment">// 无顺序</span></span><br><span class="line">	filename.Delete(<span class="number">0</span>, pos+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-경로-출력"><a href="#4-5-5-경로-출력" class="headerlink" title="4.5.5 경로 출력"></a>4.5.5 경로 출력</h4><p>일치하는 파일 이름을 얻은 후 다음 단계는 파일의 시스템 경로를 가져 오는 것입니다. 위에서 얻은 일치하는 파일 이름의 전체 이름을 ** 4.2.2 **에서 생성 된 frnPfrnNameMap 해시 테이블에 전달하여 경로를 재귀 적으로 가져옵니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CString <span class="title">Volume::getPath</span><span class="params">(DWORDLONG frn, CString &amp;path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找2</span></span><br><span class="line">	Frn_Pfrn_Name_Map::iterator it = frnPfrnNameMap.find(frn);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (it != frnPfrnNameMap.end()) &#123;</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">if</span> ( <span class="number">0</span> != it-&gt;second.pfrn ) &#123;</span><br><span class="line">		 	  getPath(it-&gt;second.pfrn, path);</span><br><span class="line">		  &#125;</span><br><span class="line"></span><br><span class="line">		  path += it-&gt;second.filename;</span><br><span class="line">		  path += ( _T(<span class="string">&quot;\&quot;) );</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	return path;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-복잡성-분석"><a href="#5-복잡성-분석" class="headerlink" title="5 복잡성 분석"></a>5 복잡성 분석</h2><h3 id="5-1-시간-복잡성"><a href="#5-1-시간-복잡성" class="headerlink" title="5.1 시간 복잡성"></a>5.1 시간 복잡성</h3><p>이론적으로 시간 복잡성은 다음과 같습니다. </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_05.jpg">그림 5-1 복잡성 분석</a> </p>
<p>AMD Athlon (tm) II X2 245 2.9GHz 프로세서에서 결과는 거의 즉각적입니다. </p>
<h3 id="5-2-공간-복잡성"><a href="#5-2-공간-복잡성" class="headerlink" title="5.2 공간 복잡성"></a>5.2 공간 복잡성</h3><p>엄청난 수의 컴퓨터 파일 (보통 10W-100W)로 인해 프로그램 자체의 메모리 사용량을 무시할 수 있습니다. </p>
<p>43M에 대한 234,708 파일. </p>
<p>오늘날 메모리가 2G 이상인 시스템의 경우 부담이되지 않습니다. </p>
<h2 id="6-문제-발생"><a href="#6-문제-발생" class="headerlink" title="6 문제 발생"></a>6 문제 발생</h2><h3 id="6-1-USN-파일을-초기화-할-수-없습니다"><a href="#6-1-USN-파일을-초기화-할-수-없습니다" class="headerlink" title="6.1 USN 파일을 초기화 할 수 없습니다."></a>6.1 USN 파일을 초기화 할 수 없습니다.</h3><p>컴퓨터의 O 디스크가 USN 로그 파일을 초기화 할 수 없습니다. 디버깅을 통해 다음을 발견했습니다. </p>
<p>DeviceIoControl은 0, GetLastError 0x70을 반환합니다. </p>
<p>msdn을 확인하십시오. 이유는 ERROR_SHARING_PAUSED입니다. </p>
<p>다음 코드를 초기화하고 추가하는 것을 잊은 것으로 나타났습니다. 프로그램은 O 디스크에 정상적으로 액세스 할 수 있습니다. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE_USN_JOURNAL_DATA cujd;</span><br><span class="line">cujd.MaximumSize = <span class="number">0</span>; <span class="comment">// 0表示使用默认值</span></span><br><span class="line">cujd.AllocationDelta = <span class="number">0</span>; <span class="comment">// 0表示使用默认值</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-유니-코드에서-wchar와-char의-문제"><a href="#6-2-유니-코드에서-wchar와-char의-문제" class="headerlink" title="6.2 유니 코드에서 wchar와 char의 문제"></a>6.2 유니 코드에서 wchar와 char의 문제</h3><p>처음에는 문자열 처리 측면에서 표준 라이브러리 함수 문자열을 처리 방법으로 사용했지만 유니 코드에서는<br>다음은 문자열 변환에 많은 문제가있는 더블 바이트 wchar로, 마지막으로 CString을 기본 문자열로 사용하고 \ _T ( “”)를 사용하여 문자열을 초기화합니다. </p>
<h3 id="6-3-ifdef-위치-문제"><a href="#6-3-ifdef-위치-문제" class="headerlink" title="6.3 #ifdef 위치 문제"></a>6.3 #ifdef 위치 문제</h3><p>\ #ifdef, 중단 점을 설정할 수 없습니다. 나중에 include 앞에 #define이 작성되었음을 알았습니다. </p>
<h3 id="6-4-매개-변수-전송"><a href="#6-4-매개-변수-전송" class="headerlink" title="6.4 매개 변수 전송"></a>6.4 매개 변수 전송</h3><p>저는 프로세스 지향적 사고로 디자인을 시작했고, 매개 변수를 전달하여 동일한 핸들을 전달해야하는 문제에 봉착했습니다. 나중에 많은 개선을 위해 클래스 메소드로 변경되었습니다. </p>
<h2 id="7-가지-작은-최적화"><a href="#7-가지-작은-최적화" class="headerlink" title="7 가지 작은 최적화"></a>7 가지 작은 최적화</h2><h3 id="7-1-읽기-속도"><a href="#7-1-읽기-속도" class="headerlink" title="7.1 읽기 속도"></a>7.1 읽기 속도</h3><p>해시 함수를 구성 할 때 세 가지 방법을 생각하고 각각 실험을하였으며 소요 시간을 계산하기 위해 시간 함수를 사용하였으며 그 결과는 다음과 같다. </p>
<p>1) 코드 수정 후 usn을 한 번 읽고 임시 파일에 저장하고 해시 테이블을 읽고 빌드 </p>
<p>각 실행 평균 시간은 약 27 초입니다. </p>
<p>2) 출시 후 벡터를 사용하여 메모리에 데이터를 저장하고, </p>
<p>결과는 만족스럽고 시간이 거의 10 배 증가했습니다! ! ! 그림 7-1에 표시된대로 : </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_06.jpg">7-1 모든 디스크 트래버스</a> </p>
<p>완전히 허용 범위 내에 있습니다. </p>
<p>첫 번째 실행은 분명히 시간이 많이 걸리고 파일은 디스크 캐시에서 미리 읽혀졌고 속도는 급증했습니다. 분석 핫스팟은 디스크 탐색 시간과 파일 읽기에 있어야합니다. </p>
<h3 id="7-2-파일-열기-방법"><a href="#7-2-파일-열기-방법" class="headerlink" title="7.2 파일 열기 방법"></a>7.2 파일 열기 방법</h3><p>** 4.3.2 **에서는 ListBox의 파일 경로를 더블 클릭하여 응답 파일을 엽니 다. 처음에는 system () 시스템 함수를 사용했지만 검은 색 콘솔 창이 나타나고 메인 창이 잠기 게됩니다. 파일이 닫힌 후에 만 ​​실행을 계속할 수 있으므로 사용자 경험에 매우 해 롭습니다. 대신 ShellExecute 함수를 호출하여 새 프로세스를 열고 기본 창을 계속 실행할 수 있습니다. </p>
<h3 id="7-3-진행률-표시-줄"><a href="#7-3-진행률-표시-줄" class="headerlink" title="7.3 진행률 표시 줄"></a>7.3 진행률 표시 줄</h3><p>V1.0 버전이 출시 된 후 일부 학생들이 배경 통계 파일을보고 할 때 메시지가 표시되지 않아 언제 완료 될지 모르겠습니다. 따라서 그림과 같이 대화 형 작업을 향상시키기 위해 기본 인터페이스 하단에 진행률 표시 줄이 추가됩니다.<br>7-2 : </p>
<p>! <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/QSearch_07.jpg">그림 7-2 진행 바</a> </p>
<p>물론 스레드 함수도 필요한 변경을했습니다. </p>
<h1 id="8-결론"><a href="#8-결론" class="headerlink" title="8 결론"></a>8 결론</h1><p>이 시점에서 프로그램의 기본 기능이 완료되었으며, 여러 컴퓨터 및 다른 시스템 (XP 이상 Windows 시리즈)에서 테스트 할 때 기본적으로 중단 된 애니메이션 및 프로그램 중단이 없습니다. </p>
<p>시간 및 기타 이유로 인해 인터페이스를 확장 할 수없고 파일 데이터를 동적으로 수집 할 수없는 등 아직 구현되지 않은 많은 기능이 있습니다. </p>
<h1 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h1><p>[1] 하드웨어 백서. NTFS 파일 시스템 사양 [OL]. Baidu Library, 2011 : 30.<br>[2] Beiyu. NTFS 파일 시스템 [OL]의 여러 기술 연구. 2007 : 7.<br>[3] 아기, 대화 형 백과 사전 [OL] <a target="_blank" rel="noopener" href="http://www.hudong.com/wiki/ntfs">http://www.hudong.com/wiki/ntfs</a><br>[4] 마이크로 소프트. MSDN Library [OL]. 2012 :<br>[5] Stanley B. Lipman / Josée LaJoie / Barbara E.Moo. C \ + \ + 프라이머 [M]. Addison-Wesley Professional, 2006 : 10.3<br>[6] Eric S. Raymond. 번역자 : Jiang Hong, He Yuan, Cai Xiaojun. The Art of UNIX Programming [m]. Publishing House of Electronics Industry, 2006 :<br>[7] Chen Hao. 소프트웨어 디자인의 일부 원칙 [OL] <a target="_blank" rel="noopener" href="http://coolshell.cn/articles/4535.html">http://coolshell.cn/articles/4535.html</a><br>[8] Sun Xin. VC ++ 심층 상세 설명 [m]. Electronics Industry, 2006<br>[9] 짐 베버리지 / 로버트 위너. Win32의 다중 스레딩 응용 프로그램 : 스레드에 대한 전체 가이드<br>[10] Addison-Wesley Professional, 1996 : 223-243 </p>
<h1 id="영어-요약"><a href="#영어-요약" class="headerlink" title="영어 요약"></a>영어 요약</h1><p>** NTFS 디스크 파일의 신속한 위치 지정 ** </p>
<p>LE IH 오스트리아 </p>
<p>(허페이 안후이 농업 대학 정보 컴퓨터 학교 230036) </p>
<p>** 개요 ** :이 문서는 Windows NTFS 디스크에 대해 설명합니다.<br>하드 디스크에있는 파일 및 폴더의 모든 이름을 열거합니다.<br>C ++ STL, MFC GUI 및 작업자 스레드를 사용하여 해시 테이블을 작성합니다.<br>궁극적으로 사용자는 Google과 같은 간단한 검색으로 키워드를 입력합니다.<br>키워드 검색 후 즉시 일치하는 모든 파일 / 폴더를 반환합니다.<br>그리고 그들의 시스템 경로. </p>
<p>** 키워드 : ** NTFS, Fast, Search, Keywords, File Path </p>

    </div>

    
    
    
      
  <div class="popular-posts-header">Related Posts</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/ko/Go-Web/" rel="bookmark">웹으로 이동</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/ko/Learn-Go-in-20-days/" rel="bookmark">20 일 만에 Go 배우기</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/ko/ios-developer-account-and-app-store/" rel="bookmark">iOS 개발자 계정 및 등록 방법</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/ko/count-lines-of-code/" rel="bookmark">코드 줄 수</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/ko/A-simple-VS-between-Sinatra-and-Martini/" rel="bookmark">간단한 VS. Sinatra와 Martini 사이</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me 👨‍💻 a coffee ☕️</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/wechat.png" alt="LeiHao WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/alipay.png" alt="LeiHao Alipay">
        <span>Alipay</span>
      </div>
      <div>
        <img src="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/bitcoin.png" alt="LeiHao Bitcoin">
        <span>Bitcoin</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/ko/tags/programming/" rel="tag"># Programming</a>
              <a href="/ko/tags/everything/" rel="tag"># Everything</a>
              <a href="/ko/tags/ntfs/" rel="tag"># NTFS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/ko/Before-graduation/" rel="next" title="졸업전 10 일 이상">
                  졸업전 10 일 이상 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2012 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-laptop-code"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeiHao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Symbols count total">330k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:01</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/ko/js/utils.js"></script><script src="/ko/js/next-boot.js"></script>

  




  <script src="/ko/js/local-search.js"></script>















  








  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://Artwalk.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://leihao0.github.io/ko/QSearch/";
    this.page.identifier = "QSearch/";
    this.page.title = "모든 것의 원리 추측과 실현";
    };
  NexT.utils.loadComments('#disqus_thread', () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://Artwalk.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
