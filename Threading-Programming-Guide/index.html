<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo-192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo-192.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="rbaH_zC-qBwXaawJ10Mno3FHzv9HRFHGFdXx2f1BwyI">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leihao0.github.io","root":"/","scheme":"Pisces","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="Threading Programming Guide 最近总是被问到 Runloop那么什么是 运行循环 呢直接看  2014-07-15 就停止修订的文档吧 👆 ～～～ 官方解说 异常清晰呢">
<meta property="og:type" content="article">
<meta property="og:title" content="Threading Programming Guide">
<meta property="og:url" content="https://leihao0.github.io/Threading-Programming-Guide/index.html">
<meta property="og:site_name" content="LeiHao&#39;s Blog">
<meta property="og:description" content="Threading Programming Guide 最近总是被问到 Runloop那么什么是 运行循环 呢直接看  2014-07-15 就停止修订的文档吧 👆 ～～～ 官方解说 异常清晰呢">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg">
<meta property="og:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg">
<meta property="article:published_time" content="2020-05-27T06:19:00.000Z">
<meta property="article:modified_time" content="2020-09-03T00:53:27.996Z">
<meta property="article:author" content="LeiHao">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg">


<link rel="canonical" href="https://leihao0.github.io/Threading-Programming-Guide/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Threading Programming Guide | LeiHao's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-159363268-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-159363268-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?25f016f633270b8e0baf56c4fe6f2dc1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="LeiHao's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LeiHao's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="nav-number">1.0.1.</span> <span class="nav-text">本文件的组织</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B"><span class="nav-number">1.0.2.</span> <span class="nav-text">也可以看看</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%88%90%E6%9C%AC"><span class="nav-number">2.0.1.</span> <span class="nav-text">线程成本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.0.2.</span> <span class="nav-text">创建一个线程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-NSThread"><span class="nav-number">2.0.2.0.1.</span> <span class="nav-text">使用 NSThread</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-POSIX-%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.0.2.0.2.</span> <span class="nav-text">使用 POSIX 线程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-NSObject-%E7%94%9F%E6%88%90%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.0.2.0.3.</span> <span class="nav-text">使用 NSObject 生成线程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8-Cocoa-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8-POSIX-%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.0.2.0.4.</span> <span class="nav-text">在 Cocoa 应用程序中使用 POSIX 线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">2.0.3.</span> <span class="nav-text">配置线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A0%86%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.0.3.0.1.</span> <span class="nav-text">配置线程的堆栈大小</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">2.0.3.0.2.</span> <span class="nav-text">配置线程本地存储</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BB%E7%8A%B6%E6%80%81"><span class="nav-number">2.0.3.0.3.</span> <span class="nav-text">设置线程的分离状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.0.3.0.4.</span> <span class="nav-text">设置线程优先级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%85%A5%E4%BE%8B%E7%A8%8B"><span class="nav-number">2.0.4.</span> <span class="nav-text">编写线程输入例程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0"><span class="nav-number">2.0.4.0.1.</span> <span class="nav-text">创建一个自动释放池</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.0.4.0.2.</span> <span class="nav-text">设置异常处理程序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.0.4.0.3.</span> <span class="nav-text">设置运行循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.0.5.</span> <span class="nav-text">终止线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.</span> <span class="nav-text">运行循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E5%89%96"><span class="nav-number">3.0.1.</span> <span class="nav-text">运行循环的解剖</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.0.1.0.1.</span> <span class="nav-text">运行循环模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%BA%90"><span class="nav-number">3.0.1.0.2.</span> <span class="nav-text">输入源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E6%9D%A5%E6%BA%90"><span class="nav-number">3.0.1.0.3.</span> <span class="nav-text">计时器来源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-number">3.0.1.0.4.</span> <span class="nav-text">运行循环观察者</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E5%BA%8F%E5%88%97"><span class="nav-number">3.0.1.0.5.</span> <span class="nav-text">事件的运行循环序列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="nav-number">3.0.2.</span> <span class="nav-text">什么时候使用运行循环？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.0.3.</span> <span class="nav-text">使用运行循环对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.0.3.0.1.</span> <span class="nav-text">获取运行循环对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.0.3.0.2.</span> <span class="nav-text">配置运行循环</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.0.3.0.3.</span> <span class="nav-text">启动运行循环</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.0.3.0.4.</span> <span class="nav-text">退出运行循环</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.0.3.0.5.</span> <span class="nav-text">线程安全和运行循环对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%BA%90"><span class="nav-number">3.0.4.</span> <span class="nav-text">配置运行循环源</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%BA%90"><span class="nav-number">3.0.4.0.1.</span> <span class="nav-text">定义自定义输入源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%AE%A1%E6%97%B6%E5%99%A8%E6%BA%90"><span class="nav-number">3.0.4.0.2.</span> <span class="nav-text">配置计时器源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BE%93%E5%85%A5%E6%BA%90"><span class="nav-number">3.0.4.0.3.</span> <span class="nav-text">配置基于端口的输入源</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">同步化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="nav-number">4.0.1.</span> <span class="nav-text">同步工具</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">4.0.1.0.1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%A3%81%E5%9E%92%E5%92%8C%E6%98%93%E5%A4%B1%E6%80%A7%E5%8F%98%E9%87%8F"><span class="nav-number">4.0.1.0.2.</span> <span class="nav-text">内存壁垒和易失性变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%94%81%E5%85%B7"><span class="nav-number">4.0.1.0.3.</span> <span class="nav-text">锁具</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.0.1.0.4.</span> <span class="nav-text">条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%80%89%E6%8B%A9%E5%99%A8%E4%BE%8B%E7%A8%8B"><span class="nav-number">4.0.1.0.5.</span> <span class="nav-text">执行选择器例程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%88%90%E6%9C%AC%E5%92%8C%E6%80%A7%E8%83%BD"><span class="nav-number">4.0.2.</span> <span class="nav-text">同步成本和性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="nav-number">4.0.3.</span> <span class="nav-text">线程安全和信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%8F%90%E7%A4%BA"><span class="nav-number">4.0.4.</span> <span class="nav-text">线程安全设计的提示</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E9%81%BF%E5%85%8D%E5%90%8C%E6%AD%A5"><span class="nav-number">4.0.4.0.1.</span> <span class="nav-text">完全避免同步</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">4.0.4.0.2.</span> <span class="nav-text">了解同步的局限性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BB%A3%E7%A0%81%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E5%A8%81%E8%83%81"><span class="nav-number">4.0.4.0.3.</span> <span class="nav-text">注意代码正确性的威胁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E5%BF%83%E6%AD%BB%E9%94%81%E5%92%8C%E6%B4%BB%E9%94%81"><span class="nav-number">4.0.4.0.4.</span> <span class="nav-text">当心死锁和活锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%98%93%E5%A4%B1%E6%80%A7%E5%8F%98%E9%87%8F"><span class="nav-number">4.0.4.0.5.</span> <span class="nav-text">正确使用易失性变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">4.0.5.</span> <span class="nav-text">使用原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%94%81"><span class="nav-number">4.0.6.</span> <span class="nav-text">使用锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-POSIX-%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">4.0.6.0.1.</span> <span class="nav-text">使用 POSIX 互斥锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-NSLock-%E7%B1%BB"><span class="nav-number">4.0.6.0.2.</span> <span class="nav-text">使用 NSLock 类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-synchronized-%E6%8C%87%E4%BB%A4"><span class="nav-number">4.0.6.0.3.</span> <span class="nav-text">使用@synchronized 指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%8F%AF%E5%8F%AF%E9%94%81"><span class="nav-number">4.0.6.0.4.</span> <span class="nav-text">使用其他可可锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.0.7.</span> <span class="nav-text">使用条件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-NSCondition-%E7%B1%BB"><span class="nav-number">4.0.7.0.1.</span> <span class="nav-text">使用 NSCondition 类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-POSIX-%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.0.7.0.2.</span> <span class="nav-text">使用 POSIX 条件</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%91%98%E8%A6%81"><span class="nav-number">5.</span> <span class="nav-text">线程安全摘要</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%AF"><span class="nav-number">5.0.1.</span> <span class="nav-text">可可</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">5.0.1.0.1.</span> <span class="nav-text">基础框架线程安全</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%A5%97%E4%BB%B6%E6%A1%86%E6%9E%B6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">5.0.1.0.2.</span> <span class="nav-text">应用套件框架线程安全</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6"><span class="nav-number">5.0.1.0.3.</span> <span class="nav-text">核心数据框架</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80"><span class="nav-number">5.0.2.</span> <span class="nav-text">核心基础</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">词汇表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E4%BF%AE%E8%AE%A2%E5%8E%86%E5%8F%B2"><span class="nav-number">7.</span> <span class="nav-text">文档修订历史</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LeiHao</p>
  <div class="site-description" itemprop="description">😃😃😃</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">181</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/leihao0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;leihao0" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/leihao0" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;leihao0" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/leihao0" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;leihao0" rel="noopener" target="_blank"><i class="fab fa-linkedin-in fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://leihao0.github.io/Threading-Programming-Guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LeiHao">
      <meta itemprop="description" content="😃😃😃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeiHao's Blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Threading Programming Guide
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-05-27 14:19:00" itemprop="dateCreated datePublished" datetime="2020-05-27T14:19:00+08:00">2020-05-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-09-03 08:53:27" itemprop="dateModified" datetime="2020-09-03T08:53:27+08:00">2020-09-03</time>
      </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/Threading-Programming-Guide/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="Threading-Programming-Guide/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>56k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>51 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1">Threading Programming Guide</a></p>
<p>最近总是被问到 Runloop<br>那么什么是 运行循环 呢<br>直接看  2014-07-15 就停止修订的文档吧 👆 ～～～</p>
<p>官方解说 异常清晰呢</p>
<a id="more"></a>

<p>👇 是 Google AI 翻译 (jifan)</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>线程是使在单个应用程序中同时执行多个代码路径成为可能的几种技术之一。尽管诸如操作对象和 Grand Central Dispatch（GCD）之类的较新技术为实现并发提供了更现代，更高效的基础架构，但是 OS X 和 iOS 还提供了用于创建和管理线程的接口。</p>
<p>本文档介绍了 OS X 中可用的线程包，并向您展示了如何使用它们。本文档还描述了为支持应用程序内的线程化和多线程代码同步而提供的相关技术。</p>
<p><strong>重要说明：</strong> 如果要开发新的应用程序，建议您研究用于实现并发性的替代 OS X 技术。如果您还不熟悉实现线程应用程序所需的设计技术，则尤其如此。这些替代技术可简化实现并发执行路径的工作量，并提供比传统线程更好的性能。有关这些技术的信息，请参见《_<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091">并发编程指南》</a>_。</p>
<h4 id="本文件的组织"><a href="#本文件的组织" class="headerlink" title="本文件的组织"></a>本文件的组织</h4><p>本文档包含以下章节和附录：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2">关于线程编程</a>介绍了线程的概念及其在应用程序设计中的作用。</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2">线程管理</a>提供有关 OS X 中的线程技术以及如何使用它们的信息。</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">运行循环</a>提供有关如何在辅助线程中管理事件处理循环的信息。</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1">同步</a>描述了同步问题以及用于防止多个线程破坏数据或使程序崩溃的工具。</li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1">线程安全摘要</a>提供了 OS X 和 iOS 及其一些关键框架的固有线程安全的高级摘要。</li>
</ul>
<h4 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h4><p>有关线程替代方法的信息，请参见《_<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091">并发编程指南》</a>_。</p>
<p>本文档仅简要介绍 POSIX 线程 API 的用法。有关可用的 POSIX 线程例程的更多信息，请参见<code>pthread</code>手册页。有关 POSIX 线程及其用法的更深入说明，请参阅 David R. Butenhof 撰写的“ <em>使用 POSIX 线程编程</em> ”。</p>
<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>OS X 或 iOS 中的每个进程（应用程序）都由一个或多个线程组成，每个线程代表通过应用程序代码执行的单个路径。每个应用程序都从一个线程开始，该线程运行该应用程序的<code>main</code>功能。应用程序可以产生其他线程，每个线程都执行特定功能的代码。</p>
<p>当应用程序产生新线程时，该线程将成为应用程序进程空间内的一个独立实体。每个线程都有其自己的执行堆栈，并由内核分别计划在运行时运行。线程可以与其他线程和其他进程通信，执行 I / O 操作以及执行您可能需要执行的其他任何操作。但是，由于它们位于同一进程空间内，因此单个应用程序中的所有线程共享同一虚拟内存空间，并且与进程本身具有相同的访问权限。</p>
<p>本章概述了 OS X 和 iOS 中可用的线程技术以及如何在应用程序中使用这些技术的示例。</p>
<p><strong>注意：</strong> 有关 Mac OS 线程体系结构的历史记录以及有关线程的其他背景信息，请参阅技术说明 TN2028，“线程体系结构”。</p>
<h4 id="线程成本"><a href="#线程成本" class="headerlink" title="线程成本"></a>线程成本</h4><p>就内存使用和性能而言，线程化会给您的程序（和系统）带来实际成本。每个线程都需要在内核内存空间和程序的内存空间中分配内存。使用有线内存将管理线程和协调其调度所需的核心结构存储在内核中。线程的堆栈空间和每个线程的数据存储在程序的内存空间中。这些结构中的大多数是在您首次创建线程时创建和初始化的，由于与内核之间的交互作用，该过程可能相对昂贵。</p>
<p>表 2-1 量化了与在应用程序中创建新的用户级线程相关的近似成本。其中一些成本是可配置的，例如分配给辅助线程的堆栈空间量。创建线程的时间成本是一个近似值，应仅用于彼此之间的相对比较。线程创建时间会因处理器负载，计算机速度以及可用系统和程序内存的数量而有很大不同。</p>
<table>
<thead>
<tr>
<th align="left">项目</th>
<th align="left">大概费用</th>
<th align="left">笔记</th>
</tr>
</thead>
<tbody><tr>
<td align="left">内核数据结构</td>
<td align="left">大约 1 KB</td>
<td align="left">该内存用于存储线程数据结构和属性，其中许多数据结构和属性分配为有线内存，因此无法分页到磁盘。</td>
</tr>
<tr>
<td align="left">堆叠空间</td>
<td align="left">512 KB（辅助线程）8 MB（OS X 主线程）1 MB（iOS 主线程）</td>
<td align="left">辅助线程允许的最小堆栈大小为 16 KB，并且堆栈大小必须为 4 KB 的倍数。在线程创建时会在进程空间中预留此内存的空间，但是直到需要它们时，才会创建与该内存关联的实际页面。</td>
</tr>
<tr>
<td align="left">创作时间</td>
<td align="left">大约 90 微秒</td>
<td align="left">该值反映了从创建线程的初始调用到线程的入口点例程开始执行之间的时间。这些数字是通过分析在基于 Intel 的 iMac（具有 2 GHz Core Duo 处理器和 1 GB 运行 OS X v10.5 的 RAM）上的线程创建过程中生成的平均值和中值确定的。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 由于具有底层内核支持，因此操作对象通常可以更快地创建线程。他们不是每次都从头开始创建线程，而是使用内核中已经存在的线程池来节省分配时间。有关使用操作对象的更多信息，请参见《_<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091">并发编程指南》</a>_。</p>
<p>编写线程代码时要考虑的另一个成本是生产成本。设计线程化的应用程序有时可能需要对组织应用程序的数据结构的方式进行根本性的更改。为避免使用同步，可能需要进行这些更改，否则同步本身可能对设计不良的应用程序造成巨大的性能损失。设计这些数据结构以及调试线程代码中的问题可能会增加开发线程应用程序所需的时间。但是，如果线程花费太多时间等待锁或不执行任何操作，则避免这些开销会在运行时产生更大的问题。</p>
<h4 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h4><p>创建低级线程相对简单。在所有情况下，您都必须具有充当线程的主要入口点的函数或方法，并且必须使用可用的线程例程之一来启动线程。以下各节显示了更常用的线程技术的基本创建过程。使用这些技术创建的线程将继承一组默认属性，这些属性由您使用的技术确定。有关如何配置线程的信息，请参阅“ <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW8">配置线程属性”</a>。</p>
<h6 id="使用-NSThread"><a href="#使用-NSThread" class="headerlink" title="使用 NSThread"></a>使用 NSThread</h6><p>有两种使用<code>NSThread</code>该类创建线程的方法：</p>
<ul>
<li>使用<code>detachNewThreadSelector:toTarget:withObject:</code>class 方法产生新线程。</li>
<li>创建一个新<code>NSThread</code>对象并调用其<code>start</code>方法。（仅在 iOS 和 OS X v10.5 及更高版本中受支持。）</li>
</ul>
<p>两种技术都会在您的应用程序中创建一个分离线程。分离的线程意味着线程退出时系统会自动回收线程的资源。这也意味着您的代码以后不必与线程显式连接。</p>
<p>由于该<code>detachNewThreadSelector:toTarget:withObject:</code>方法在 OS X 的所有版本中均受支持，因此经常在使用线程的现有 Cocoa 应用程序中找到。要分离新线程，只需提供要用作线程入口点的方法名称（指定为选择器），定义该方法的对象以及要在启动时传递给线程的任何数据。 。以下示例显示了此方法的基本调用，该调用使用当前对象的自定义方法生成一个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector：@selector（myThreadMainMethod :) toTarget：self withObject：nil];</span><br></pre></td></tr></table></figure>

<p>在 OS X v10.5 之前，您<code>NSThread</code>主要使用该类生成线程。尽管您可以获取<code>NSThread</code>对象并访问某些线程属性，但是只能在线程运行之后从线程本身进行操作。在 OS X v10.5 中，添加了对创建<code>NSThread</code>对象的支持，而无需立即产生相应的新线程。（此支持在 iOS 中也可用。）此支持使得可以在启动线程之前获取和设置各种线程属性。这也使得以后可以使用该线程对象来引用正在运行的线程。</p>
<p><code>NSThread</code>在 OS X v10.5 及更高版本中初始化对象的简单方法是使用该<code>initWithTarget:selector:object:</code>方法。此方法<code>detachNewThreadSelector:toTarget:withObject:</code>使用与该方法完全相同的信息，并使用它来初始化新<code>NSThread</code>实例。但是，它不会启动线程。要启动线程，请<code>start</code>显式调用线程对象的方法，如以下示例所示：</p>
<table>
<thead>
<tr>
<th><code>NSThread * myThread = [[NSThread分配] initWithTarget：self</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>选择器：@选择器（myThreadMainMethod :)</code></td>
</tr>
<tr>
<td><code>对象：无]；</code></td>
</tr>
<tr>
<td><code>[myThread开始]; //实际创建线程</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 使用该<code>initWithTarget:selector:object:</code>方法的另一种方法是继承<code>NSThread</code>并覆盖其<code>main</code>方法。您将使用此方法的重写版本来实现线程的主入口点。有关更多信息，请参见《*<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsthread">NSThread 类参考》中</a>*的子类注释。</p>
<p>如果您有一个<code>NSThread</code>对象的线程当前正在运行，则可以向该线程发送消息的<code>performSelector:onThread:withObject:waitUntilDone:</code>一种方法是使用应用程序中几乎所有对象的方法。OS X v10.5 中引入了对在线程（主线程除外）上执行选择器的支持，这是在线程之间进行通信的便捷方式。（此支持在 iOS 中也可用。）使用此技术发送的消息由另一个线程直接执行，作为其正常运行循环处理的一部分。（当然，这确实意味着目标线程必须在其运行循环中运行；请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">“运行循环”</a>。）以这种方式进行通信时，您可能仍需要某种形式的同步，但是比在线程之间设置通信端口更简单。线程。</p>
<p><strong>注意：</strong> 尽管对于线程间的偶尔通信很有用，但是您不应将 <code>performSelector:onThread:withObject:waitUntilDone:</code>方法用于时间紧迫或线程间的频繁通信。</p>
<p>有关其他线程通信选项的列表，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW3">设置</a>线程<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW3">的分离状态</a>。</p>
<h6 id="使用-POSIX-线程"><a href="#使用-POSIX-线程" class="headerlink" title="使用 POSIX 线程"></a>使用 POSIX 线程</h6><p>OS X 和 iOS 为使用 POSIX 线程 API 创建线程提供了基于 C 的支持。该技术实际上可以在任何类型的应用程序（包括 Cocoa 和 Cocoa Touch 应用程序）中使用，如果您要为多个平台编写软件，则可能会更加方便。适当地调用了用于创建线程的 POSIX 例程<code>pthread_create</code>。</p>
<p>清单 2-1 显示了两个使用 POSIX 调用创建线程的自定义函数。该<code>LaunchThread</code>函数创建一个新线程，其主例程在该<code>PosixThreadMainRoutine</code>函数中实现。由于 POSIX 默认将线程创建为可连接线程，因此本示例更改了线程的属性以创建分离的线程。将线程标记为已分离使系统有机会在退出时立即回收该线程的资源。</p>
<p><strong>清单 2-1</strong> 在 C 中创建线程</p>
<table>
<thead>
<tr>
<th><code>#include</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>#include</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>void * PosixThreadMainRoutine（void *数据）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//在这里做一些工作。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>返回NULL;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>无效LaunchThread（）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//使用POSIX例程创建线程。</code></td>
</tr>
<tr>
<td><code>pthread_attr_t attr;</code></td>
</tr>
<tr>
<td><code>pthread_t posixThreadID;</code></td>
</tr>
<tr>
<td><code>int returnVal;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>returnVal = pthread_attr_init（＆attr）;</code></td>
</tr>
<tr>
<td><code>assert（！returnVal）;</code></td>
</tr>
<tr>
<td><code>returnVal = pthread_attr_setdetachstate（＆attr，PTHREAD_CREATE_DETACHED）;</code></td>
</tr>
<tr>
<td><code>assert（！returnVal）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>int threadError = pthread_create（＆posixThreadID，＆attr，＆PosixThreadMainRoutine，NULL）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>returnVal = pthread_attr_destroy（＆attr）;</code></td>
</tr>
<tr>
<td><code>assert（！returnVal）;</code></td>
</tr>
<tr>
<td><code>如果（threadError！= 0）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//报告错误。</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>如果将上述清单中的代码添加到一个源文件中并调用该<code>LaunchThread</code>函数，它将在您的应用程序中创建一个新的分离线程。当然，使用此代码创建的新线程将无用。线程将启动，几乎立即退出。为了使事情变得更有趣，您需要向该<code>PosixThreadMainRoutine</code>函数添加代码以完成一些实际工作。为了确保线程知道要执行的工作，可以在创建时将其传递给一些数据的指针。您将此指针作为<code>pthread_create</code>函数的最后一个参数传递。</p>
<p>要将信息从新创建的线程传递回应用程序的主线程，您需要在目标线程之间建立通信路径。对于基于 C 的应用程序，有多种方法可以在线程之间进行通信，包括使用端口，条件或共享内存。对于寿命长的线程，几乎应该始终设置某种线程间通信机制，以为应用程序的主线程提供一种检查线程状态或在应用程序退出时将其干净关闭的方法。</p>
<p>有关 POSIX 线程功能的更多信息，请参见<code>pthread</code>手册页。</p>
<h6 id="使用-NSObject-生成线程"><a href="#使用-NSObject-生成线程" class="headerlink" title="使用 NSObject 生成线程"></a>使用 NSObject 生成线程</h6><p>在 iOS 和 OS X v10.5 及更高版本中，所有对象都可以生成新线程并使用它执行其方法之一。该<code>performSelectorInBackground:withObject:</code>方法创建一个新的分离线程，并使用指定的方法作为新线程的入口点。例如，如果您有某个对象（由表示<code>myObj</code>），并且该对象具有一个<code>doSomething</code>要在后台线程中运行的方法，则可以使用以下代码来执行该操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObj performSelectorInBackground：@selector（doSomething）withObject：nil];</span><br></pre></td></tr></table></figure>

<p>调用此方法的效果是一样的，如果你调用<code>detachNewThreadSelector:toTarget:withObject:</code>的方法<code>NSThread</code>与当前对象，选择和参数对象作为参数。立即使用默认配置生成新线程并开始运行。在选择器内部，必须像配置任何线程一样配置线程。例如，如果您打算使用自动释放池（如果您不使用垃圾回收），则需要设置它，并配置线程的运行循环。有关如何配置新线程的信息，请参阅“ <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW8">配置线程属性”</a>。</p>
<h6 id="在-Cocoa-应用程序中使用-POSIX-线程"><a href="#在-Cocoa-应用程序中使用-POSIX-线程" class="headerlink" title="在 Cocoa 应用程序中使用 POSIX 线程"></a>在 Cocoa 应用程序中使用 POSIX 线程</h6><p>尽管<code>NSThread</code>该类是在 Cocoa 应用程序中创建线程的主要接口，但是您可以自由使用 POSIX 线程，如果这样做对您更方便。例如，如果您已经有使用 POSIX 线程的代码并且不想重写它，则可以使用。如果确实打算在 Cocoa 应用程序中使用 POSIX 线程，则仍应了解 Cocoa 和线程之间的交互作用，并遵守以下各节中的准则。</p>
<p>######## 保护可可框架</p>
<p>对于多线程应用程序，Cocoa 框架使用锁和其他形式的内部同步来确保它们的行为正确。但是，为了防止这些锁在单线程情况下降低性能，在应用程序使用<code>NSThread</code>类产生其第一个新线程之前，Cocoa 不会创建它们。如果仅使用 POSIX 线程例程生成线程，则 Cocoa 不会收到需要知道您的应用程序现在是多线程的通知。发生这种情况时，涉及 Cocoa 框架的操作可能会使您的应用程序不稳定或崩溃。</p>
<p>为了让 Cocoa 知道您打算使用多个线程，您所要做的就是使用<code>NSThread</code>类产生一个线程，然后立即退出该线程。您的线程入口点无需执行任何操作。仅使用生成一个线程的行为<code>NSThread</code>就足以确保将 Cocoa 框架所需的锁放置到位。</p>
<p>如果不确定 Cocoa 是否认为您的应用程序是多线程的，则可以使用的<code>isMultiThreaded</code>方法<code>NSThread</code>进行检查。</p>
<p>######## 混合 POSIX 和可可锁</p>
<p>在同一应用程序中混合使用 POSIX 和 Cocoa 锁是安全的。可可锁和条件对象实际上只是 POSIX 互斥对象和条件的包装。但是，对于给定的锁，必须始终使用相同的接口来创建和操作该锁。换句话说，您不能使用 Cocoa <code>NSLock</code>对象来操纵使用该<code>pthread_mutex_init</code>函数创建的互斥对象，反之亦然。</p>
<h4 id="配置线程属性"><a href="#配置线程属性" class="headerlink" title="配置线程属性"></a>配置线程属性</h4><p>在创建线程之后，有时甚至在创建线程之前，您可能需要配置线程环境的不同部分。以下各节描述了可以进行的某些更改以及何时进行更改。</p>
<h6 id="配置线程的堆栈大小"><a href="#配置线程的堆栈大小" class="headerlink" title="配置线程的堆栈大小"></a>配置线程的堆栈大小</h6><p>对于您创建的每个新线程，系统都会在进程空间中分配特定数量的内存，以充当该线程的堆栈。堆栈管理堆栈帧，也是声明线程的任何局部变量的地方。为线程分配的内存量在“ <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7">线程成本”中</a>列出。</p>
<p>如果要更改给定线程的堆栈大小，则必须在创建线程之前进行更改。尽管<code>NSThread</code>只有 iOS 和 OS X v10.5 及更高版本才提供使用设置堆栈大小的功能，但是所有线程技术都提供了一些设置堆栈大小的方法。表 2-2 列出了每种技术的不同选项。</p>
<table>
<thead>
<tr>
<th align="left">技术</th>
<th align="left">选项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可可</td>
<td align="left">在 iOS 和 OS X v10.5 及更高版本中，分配和初始化<code>NSThread</code>对象（请勿使用<code>detachNewThreadSelector:toTarget:withObject:</code>方法）。在调用<code>start</code>线程对象的方法之前，请使用该<code>setStackSize:</code>方法指定新的堆栈大小。</td>
</tr>
<tr>
<td align="left">POSIX</td>
<td align="left">创建一个新<code>pthread_attr_t</code>结构，并使用该<code>pthread_attr_setstacksize</code>函数更改默认堆栈大小。<code>pthread_create</code>创建线程时，将属性传递给函数。</td>
</tr>
<tr>
<td align="left">多处理服务</td>
<td align="left"><code>MPCreateTask</code>创建线程时，将适当的堆栈大小值传递给函数。</td>
</tr>
</tbody></table>
<h6 id="配置线程本地存储"><a href="#配置线程本地存储" class="headerlink" title="配置线程本地存储"></a>配置线程本地存储</h6><p>每个线程维护一个键-值对的字典，可以从线程中的任何位置进行访问。您可以使用此词典存储要在整个线程执行过程中保留的信息。例如，您可以使用它存储要在线程运行循环的多次迭代中保留的状态信息。</p>
<p>Cocoa 和 POSIX 以不同的方式存储线程字典，因此您不能混合和匹配对这两种技术的调用。但是，只要您在线程代码中坚持使用一种技术，最终结果应该是相似的。在 Cocoa 中，可以使用对象的<code>threadDictionary</code>方法<code>NSThread</code>来检索<code>NSMutableDictionary</code>对象，可以在该对象中添加线程所需的任何键。在 POSIX 中，您可以使用<code>pthread_setspecific</code>和<code>pthread_getspecific</code>函数来设置和获取线程的键和值。</p>
<h6 id="设置线程的分离状态"><a href="#设置线程的分离状态" class="headerlink" title="设置线程的分离状态"></a>设置线程的分离状态</h6><p>默认情况下，大多数高级线程技术都会创建分离的线程。在大多数情况下，最好使用分离的线程，因为它们允许系统在线程完成后立即释放线程的数据结构。分离的线程也不需要与程序进行显式交互。从线程中检索结果的方法由您自行决定。相比之下，系统不会为可连接线程回收资源，直到另一个线程与该线程显式连接为止，该过程可能会阻塞执行该连接的线程。</p>
<p>您可以将可连接线程视为类似于子线程。尽管它们仍然作为独立线程运行，但是在系统可以回收其资源之前，可连接线程必须由另一个线程连接。可连接线程还提供了一种显式的方法，可将数据从退出线程传递到另一个线程。在连接退出之前，可连接线程可以将数据指针或其他返回值传递给该<code>pthread_exit</code>函数。然后另一个线程可以通过调用该<code>pthread_join</code>函数来声明此数据。</p>
<p><strong>重要：</strong> 在应用程序退出时，分离的线程可以立即终止，但可连接的线程不能终止。在允许进程退出之前，必须先连接每个可连接线程。因此，在线程正在执行不应中断的关键工作（例如将数据保存到磁盘）的情况下，可连接线程可能更可取。</p>
<p>如果确实要创建可连接线程，则唯一的方法是使用 POSIX 线程。POSIX 默认将线程创建为可连接线程。要将线程标记为分离的或可联接的，请<code>pthread_attr_setdetachstate</code>在创建线程之前使用函数修改线程属性。线程开始后，您可以通过调用<code>pthread_detach</code>函数将可连接线程更改为分离线程。有关这些 POSIX 线程功能的更多信息，请参见<code>pthread</code>手册页。有关如何加入线程的信息，请参见<code>pthread_join</code>手册页。</p>
<h6 id="设置线程优先级"><a href="#设置线程优先级" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h6><p>您创建的任何新线程都具有与之关联的默认优先级。内核的调度算法在确定要运行的线程时会考虑线程优先级，与优先级较低的线程相比，优先级较高的线程更有可能运行。较高的优先级并不能保证您的线程有特定的执行时间，只是与较低优先级的线程相比，调度程序更可能选择该时间。</p>
<p><strong>重要说明：</strong> 通常最好将线程的优先级保留为默认值。增加某些线程的优先级也会增加低优先级线程之间出现饥饿的可能性。如果您的应用程序包含必须彼此交互的高优先级和低优先级线程，则低优先级线程的饥饿可能会阻塞其他线程并造成性能瓶颈。</p>
<p>如果您确实想修改线程优先级，那么 Cocoa 和 POSIX 都提供了一种方法。对于 Cocoa 线程，可以使用的<code>setThreadPriority:</code>class 方法<code>NSThread</code>来设置当前正在运行的线程的优先级。对于 POSIX 线程，请使用<code>pthread_setschedparam</code>函数。有关更多信息，请参见*<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsthread">NSThread 类参考</a>*或<code>pthread_setschedparam</code>手册页。</p>
<h4 id="编写线程输入例程"><a href="#编写线程输入例程" class="headerlink" title="编写线程输入例程"></a>编写线程输入例程</h4><p>在大多数情况下，OS X 中线程入口点例程的结构与其他平台上的相同。您可以初始化数据结构，进行一些工作或有选择地设置运行循环，并在线程代码完成后进行清理。根据您的设计，编写输入例程时可能需要执行一些其他步骤。</p>
<h6 id="创建一个自动释放池"><a href="#创建一个自动释放池" class="headerlink" title="创建一个自动释放池"></a>创建一个自动释放池</h6><p>在 Objective-C 框架中链接的应用程序通常必须在其每个线程中至少创建一个自动释放池。如果应用程序使用托管模型（该应用程序负责对象的保留和释放），则自动释放池将捕获从该线程自动释放的所有对象。</p>
<p>如果应用程序使用垃圾回收而不是托管内存模型，则不一定必须创建自动释放池。垃圾收集应用程序中自动释放池的存在无害，并且在大多数情况下都将被忽略。在代码模块必须同时支持垃圾回收和托管内存模型的情况下，允许使用此方法。在这种情况下，必须存在自动释放池以支持托管内存模型代码，并且如果在启用垃圾回收的情况下运行应用程序，则将自动忽略该释放池。</p>
<p>如果您的应用程序使用托管内存模型，则创建自动释放池应该是您在线程输入例程中要做的第一件事。同样，销毁此自动释放池应该是线程中的最后一件事。该池确保捕获自动释放的对象，尽管它直到线程本身退出才释放它们。清单 2-2 显示了使用自动释放池的基本线程输入例程的结构。</p>
<p><strong>清单 2-2</strong> 定义线程入口点例程</p>
<table>
<thead>
<tr>
<th><code>-（无效）myThreadMainRoutine</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; //顶级池</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//在这里做线程工作。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[池释放]; //释放池中的对象。</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>由于顶级自动释放池在线程退出之前不会释放其对象，因此长寿命的线程应创建其他自动释放池以更频繁地释放对象。例如，使用运行循环的线程可能每次通过该运行循环都会创建并释放一个自动释放池。更频繁地释放对象可以防止应用程序的内存占用量过大，从而可能导致性能问题。但是，与任何与性能相关的行为一样，您应该测量代码的实际性能，并适当调整自动释放池的使用。</p>
<p>有关内存管理和自动释放池的更多信息，请参见《_<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i">高级内存管理编程指南》</a>_。</p>
<h6 id="设置异常处理程序"><a href="#设置异常处理程序" class="headerlink" title="设置异常处理程序"></a>设置异常处理程序</h6><p>如果您的应用程序捕获并处理了异常，则应准备好线程代码以捕获可能发生的任何异常。尽管最好在可能发生异常的地方处理异常，但是未能捕获线程中引发的异常会导致应用程序退出。在线程输入例程中安装最终的 try / catch 可以捕获任何未知的异常并提供适当的响应。</p>
<p>在 Xcode 中构建项目时，可以使用 C ++或 Objective-C 异常处理样式。有关在 Objective-C 中设置如何引发和捕获异常的信息，请参见*<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i">异常编程主题</a>*。</p>
<h6 id="设置运行循环"><a href="#设置运行循环" class="headerlink" title="设置运行循环"></a>设置运行循环</h6><p>在编写要在单独的线程上运行的代码时，有两个选择。第一种选择是将线程的代码编写为一个很长的任务而几乎不中断执行，也不会中断，并在完成时退出线程。第二种选择是将您的线程置于循环中，并使其在到达请求时动态处理请求。第一个选项不需要为您的代码进行特殊设置。您只需开始做您想做的工作。但是，第二个选项涉及设置线程的运行循环。</p>
<p>OS X 和 iOS 为在每个线程中实现运行循环提供了内置支持。应用程序框架会自动启动应用程序主线程的运行循环。如果创建任何辅助线程，则必须配置运行循环并手动启动它。</p>
<p>有关使用和配置运行循环的信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">“运行循环”</a>。</p>
<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><p>建议的退出线程的方法是让其正常退出其入口点例程。尽管 Cocoa，POSIX 和 Multiprocessing Services 提供了直接杀死线程的例程，但强烈建议不要使用此类例程。杀死线程可防止该线程在其自身清除后清理。线程分配的内存可能会泄漏，线程当前正在使用的任何其他资源可能无法正确清理，从而在以后产生潜在的问题。</p>
<p>如果您预计需要在操作过程中终止线程，则应从一开始就设计线程以响应取消或退出消息。对于长时间运行的操作，这可能意味着要定期停止工作并检查是否收到此消息。如果确实有消息要求线程退出，则该线程将有机会执行所需的清理并正常退出；否则，它可以简单地返回工作并处理下一个数据块。</p>
<p>响应取消消息的一种方法是使用运行循环输入源接收此类消息。清单 2-3 显示了该代码在线程的主入口例程中的外观结构。（该示例仅显示了主循环部分，不包括设置自动释放池或配置要执行的实际工作的步骤。）该示例在运行循环上安装了一个自定义输入源，该输入源大概可以从另一个您的线程；有关设置输入源的信息，请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7">配置运行循环源</a>。在完成全部工作量的一部分后，线程会短暂运行运行循环，以查看消息是否到达输入源。如果不是，则运行循环立即退出，并且循环继续进行下一个工作块。因为处理程序无法直接访问<code>exitNow</code>局部变量，所以退出条件通过线程字典中的键值对传达。</p>
<p><strong>清单 2-3</strong> 在长时间工作期间检查退出条件</p>
<table>
<thead>
<tr>
<th><code>-（无效）threadMainRoutine</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>BOOL moreWorkToDo = YES;</code></td>
</tr>
<tr>
<td><code>BOOL exitNow = NO;</code></td>
</tr>
<tr>
<td><code>NSRunLoop * runLoop = [NSRunLoop currentRunLoop];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//将exitNow BOOL添加到线程字典中。</code></td>
</tr>
<tr>
<td><code>NSMutableDictionary * threadDict = [[[NSThread currentThread] threadDictionary];</code></td>
</tr>
<tr>
<td><code>[threadDict setValue：[NSNumber numberWithBool：exitNow] forKey：@“ ThreadShouldExitNow”];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//安装输入源。</code></td>
</tr>
<tr>
<td><code>[self myInstallCustomInputSource];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>同时（moreWorkToDo &amp;&amp;！exitNow）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//在这里做一大块工作。</code></td>
</tr>
<tr>
<td><code>//完成后更改moreWorkToDo布尔值。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//运行运行循环，但如果输入源不等待触发，则立即超时。</code></td>
</tr>
<tr>
<td><code>[runLoop runUntilDate：[NSDate date]];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//检查输入源处理程序是否更改了exitNow值。</code></td>
</tr>
<tr>
<td><code>exitNow = [[threadDict valueForKey：@“ ThreadShouldExitNow”] boolValue];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<h2 id="运行循环"><a href="#运行循环" class="headerlink" title="运行循环"></a>运行循环</h2><p>运行循环是与线程关联的基础架构的一部分。一个<em>运行循环</em>是一个事件处理循环，你用它来安排工作，并协调接收传入的事件。运行循环的目的是在有工作要做时让线程忙，而在没有工作时让线程进入睡眠状态。</p>
<p>运行循环管理不是完全自动的。您仍然必须设计线程的代码以在适当的时间启动运行循环并响应传入的事件。Cocoa 和 Core Foundation 都提供了<em>运行循环对象，</em>以帮助您配置和管理线程的运行循环。您的应用程序不需要显式创建这些对象。每个线程（包括应用程序的主线程）都有一个关联的运行循环对象。但是，只有辅助线程需要显式地运行其运行循环。在应用程序启动过程中，应用程序框架会自动在主线程上设置并运行运行循环。</p>
<p>以下各节提供有关运行循环以及如何为应用程序配置循环的更多信息。有关运行循环对象的其他信息，请参见《*<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsrunloop">NSRunLoop 类参考》</a>*和《_<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corefoundation/cfrunloop">CFRunLoop 参考》</a>_。</p>
<h4 id="运行循环的解剖"><a href="#运行循环的解剖" class="headerlink" title="运行循环的解剖"></a>运行循环的解剖</h4><p>运行循环非常像其名称听起来。这是您的线程进入的一个循环，用于响应传入事件而运行事件处理程序。您的代码提供了用于实现运行循环的实际循环部分的控制语句-换句话说，您的代码提供了驱动运行循环的<code>while</code>or <code>for</code>循环。在循环内，您可以使用运行循环对象来“运行”事件处理代码，以接收事件并调用已安装的处理程序。</p>
<p>运行循环从两种不同类型的源接收事件。<em>输入源</em>传递异步事件，通常是来自另一个线程或其他应用程序的消息。<em>计时器源</em>传递同步事件，这些事件在计划的时间或重复的间隔发生。两种类型的源都使用特定于应用程序的处理程序例程来处理事件到达时的事件。</p>
<p>图 3-1 显示了运行循环和各种来源的概念结构。输入源将异步事件传递给相应的处理程序，并导致<code>runUntilDate:</code>方法（在线程的关联<code>NSRunLoop</code>对象上调用）退出。计时器源将事件传递到其处理程序例程，但不会导致运行循环退出。</p>
<p><strong>图 3-1</strong> 运行循环的结构及其来源<img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="运行循环的结构及其来源"></p>
<p>除了处理输入源之外，运行循环还生成有关运行循环行为的通知。注册的<em>运行循环观察者</em>可以接收这些通知，并使用它们在线程上进行其他处理。您可以使用 Core Foundation 在线程上安装运行循环观察器。</p>
<p>以下各节提供有关运行循环的组件及其运行方式的更多信息。它们还描述了事件处理期间在不同时间生成的通知。</p>
<h6 id="运行循环模式"><a href="#运行循环模式" class="headerlink" title="运行循环模式"></a>运行循环模式</h6><p>一个<em>运行的循环模式</em>是输入源和定时器的集合进行监测和运行循环观察员集合通知。每次运行运行循环时，都可以（显式或隐式）指定运行的特定“模式”。在运行循环的整个过程中，仅监视与该模式关联的源，并允许其传递事件。（类似地，仅将与该模式关联的观察者通知运行循环的进度。）与其他模式关联的源将保留任何新事件，直到随后以适当的模式通过循环。</p>
<p>在代码中，您可以通过名称识别模式。Cocoa 和 Core Foundation 都定义了默认模式和几种常用模式，以及用于在代码中指定这些模式的字符串。您可以通过简单地为模式名称指定自定义字符串来定义自定义模式。尽管您分配给自定义模式的名称是任意的，但是这些模式的内容不是任意的。您必须确保将一个或多个输入源，计时器或运行循环观察器添加到您创建的任何模式中，以使其有用。</p>
<p>您可以使用模式从运行循环的特定遍历中过滤掉有害来源的事件。大多数情况下，您将需要在系统定义的“默认”模式下运行运行循环。但是，模式面板可以在“模式”模式下运行。在这种模式下，只有与模式面板相关的源才将事件传递给线程。对于辅助线程，您可以使用自定义模式来防止低优先级源在时间紧迫的操作期间传递事件。</p>
<p><strong>注意：</strong> 模式是根据事件的来源而不是事件的类型来区分的。例如，您不会使用仅匹配鼠标按下事件或仅匹配键盘事件的模式。您可以使用模式来侦听另一组端口，暂时暂停计时器，或者以其他方式更改源并运行当前正在监视的循环观察器。</p>
<p>表 3-1 列出了 Cocoa 和 Core Foundation 定义的标准模式，以及何时使用该模式的说明。名称列列出了用于在代码中指定模式的实际常量。</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">默认</td>
<td align="left"><code>NSDefaultRunLoopMode</code> （可可）<code>kCFRunLoopDefaultMode</code> （核心基金会）</td>
<td align="left">默认模式是用于大多数操作的模式。大多数时候，您应该使用此模式来启动运行循环并配置输入源。</td>
</tr>
<tr>
<td align="left">连接</td>
<td align="left"><code>NSConnectionReplyMode</code> （可可）</td>
<td align="left">可可将此模式与<code>NSConnection</code>对象结合使用以监视答复。您很少需要自己使用此模式。</td>
</tr>
<tr>
<td align="left">模态</td>
<td align="left"><code>NSModalPanelRunLoopMode</code> （可可）</td>
<td align="left">可可使用此模式来识别用于模式面板的事件。</td>
</tr>
<tr>
<td align="left">事件追踪</td>
<td align="left"><code>NSEventTrackingRunLoopMode</code> （可可）</td>
<td align="left">可可使用此模式来限制鼠标拖动循环和其他类型的用户界面跟踪循环期间的传入事件。</td>
</tr>
<tr>
<td align="left">普通模式</td>
<td align="left"><code>NSRunLoopCommonModes</code> （可可）<code>kCFRunLoopCommonModes</code> （核心基金会）</td>
<td align="left">这是一组可配置的常用模式。将输入源与此模式相关联还将其与组中的每个模式相关联。对于 Cocoa 应用程序，此集合默认包括默认，模式和事件跟踪模式。最初，Core Foundation 仅包括默认模式。您可以使用该<code>CFRunLoopAddCommonMode</code>功能将自定义模式添加到集合中。</td>
</tr>
</tbody></table>
<h6 id="输入源"><a href="#输入源" class="headerlink" title="输入源"></a>输入源</h6><p>输入源将事件异步传递到您的线程。事件的来源取决于输入来源的类型，通常是两个类别之一。基于端口的输入源监视您的应用程序的 Mach 端口。定制输入源监视事件的定制源。就您的运行循环而言，输入源是基于端口的还是定制的都无关紧要。系统通常实现两种类型的输入源，您可以按原样使用。两种信号源之间的唯一区别是信号的发送方式。基于端口的源由内核自动发出信号，而自定义源必须从另一个线程手动发出信号。</p>
<p>创建输入源时，可以将其分配给运行循环的一种或多种模式。模式会影响在任何给定时刻监视哪些输入源。大多数情况下，您会在默认模式下运行运行循环，但也可以指定自定义模式。如果输入源不在当前监视的模式下，则它生成的任何事件都将保留，直到运行循环以正确的模式运行。</p>
<p>以下各节描述了一些输入源。</p>
<p>######## 基于端口的源</p>
<p>Cocoa 和 Core Foundation 提供了内置支持，用于使用与端口相关的对象和功能创建基于端口的输入源。例如，在可可中，您根本不必直接创建输入源。您只需创建一个端口对象，然后使用的方法<code>NSPort</code>将该端口添加到运行循环中。端口对象为您处理所需输入源的创建和配置。</p>
<p>在 Core Foundation 中，您必须手动创建端口及其运行循环源。在这两种情况下，您使用的端口类型不透明（相关的功能<code>CFMachPortRef</code>，<code>CFMessagePortRef</code>或<code>CFSocketRef</code>）创建合适的对象。</p>
<p>有关如何设置和配置基于端口的自定义源的示例，请参阅“ <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281">配置基于端口的输入源”</a>。</p>
<p>######## 自定义输入源</p>
<p>要创建自定义输入源，必须使用与<code>CFRunLoopSourceRef</code>Core Foundation 中的不透明类型关联的功能。您可以使用多个回调函数配置自定义输入源。当从运行循环中删除源时，Core Foundation 会在不同位置调用这些函数以配置源，处理所有传入事件并拆除源。</p>
<p>除了定义事件到达时自定义源的行为外，还必须定义事件传递机制。源代码的这一部分在单独的线程上运行，负责为输入源提供其数据，并在准备好处理数据时向其发出信号。事件传递机制取决于您，但不必过于复杂。</p>
<p>有关如何创建自定义输入源的示例，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3">定义自定义输入源</a>。有关自定义输入源的参考信息，另请参见*<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corefoundation/cfrunloopsource-rhr">CFRunLoopSource 参考</a>*。</p>
<p>######## 可可执行选择器来源</p>
<p>除了基于端口的源代码外，Cocoa 还定义了一个自定义输入源，使您可以在任何线程上执行选择器。像基于端口的源一样，执行选择器请求在目标线程上被序列化，从而减轻了在一个线程上运行多个方法时可能发生的许多同步问题。与基于端口的源不同，执行选择器源在执行选择器后将其自身从运行循环中删除。</p>
<p><strong>注意：</strong> 在 OS X v10.5 之前，执行选择器源主要用于将消息发送到主线程，但是在 OS X v10.5 和更高版本以及 iOS 中，可以使用它们将消息发送到任何线程。</p>
<p>在另一个线程上执行选择器时，目标线程必须具有活动的运行循环。对于您创建的线程，这意味着等到您的代码显式启动运行循环。但是，由于主线程启动了自己的运行循环，因此您可以在应用程序调用<code>applicationDidFinishLaunching:</code>应用程序委托的方法后立即开始在该线程上发出调用 。每次循环时，运行循环都会处理所有排队的执行选择器调用，而不是在每次循环迭代时都处理一个。</p>
<p>表 3-2 列出了<code>NSObject</code>可在其他线程上执行选择器的方法。由于这些方法是在上声明的<code>NSObject</code>，因此可以在可以访问 Objective-C 对象的任何线程（包括 POSIX 线程）中使用它们。这些方法实际上不会创建新线程来执行选择器。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>performSelectorOnMainThread:withObject:waitUntilDone:``performSelectorOnMainThread:withObject:waitUntilDone:modes:</code></td>
<td align="left">在该线程的下一个运行循环周期内，在该应用程序的主线程上执行指定的选择器。这些方法使您可以选择阻塞当前线程，直到执行选择器为止。</td>
</tr>
<tr>
<td align="left"><code>performSelector:onThread:withObject:waitUntilDone:``performSelector:onThread:withObject:waitUntilDone:modes:</code></td>
<td align="left">在具有<code>NSThread</code>对象的任何线程上执行指定的选择器。这些方法使您可以选择阻塞当前线程，直到执行选择器为止。</td>
</tr>
<tr>
<td align="left"><code>performSelector:withObject:afterDelay:``performSelector:withObject:afterDelay:inModes:</code></td>
<td align="left">在下一个运行循环周期和一个可选的延迟时间之后，在当前线程上执行指定的选择器。因为它一直等到下一个运行循环周期执行选择器，所以这些方法提供了当前执行代码的最小自动延迟。多个排队的选择器按照排队的顺序依次执行。</td>
</tr>
<tr>
<td align="left"><code>cancelPreviousPerformRequestsWithTarget:``cancelPreviousPerformRequestsWithTarget:selector:object:</code></td>
<td align="left">使您可以使用<code>performSelector:withObject:afterDelay:</code>or <code>performSelector:withObject:afterDelay:inModes:</code>方法取消发送到当前线程的消息。</td>
</tr>
</tbody></table>
<p>有关每种方法的详细信息，请参见《_<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/nsobject">NSObject 类参考》</a>_。</p>
<h6 id="计时器来源"><a href="#计时器来源" class="headerlink" title="计时器来源"></a>计时器来源</h6><p>计时器源在将来的预设时间将事件同步传递到您的线程。计时器是线程通知自己执行某事的一种方式。例如，一旦在来自用户的连续击键之间经过了一定的时间量，则搜索字段可以使用计时器来启动自动搜索。使用此延迟时间使用户有机会在开始搜索之前键入尽可能多的所需搜索字符串。</p>
<p>尽管计时器生成基于时间的通知，但它不是实时机制。像输入源一样，计时器与运行循环的特定模式相关联。如果计时器不在运行循环当前正在监视的模式下，则在您以计时器支持的一种模式运行运行循环之前，它不会触发。同样，如果运行循环在执行处理程序例程的中间触发计时器，则计时器将等到下一次通过运行循环调用其处理例程。如果运行循环根本没有运行，则计时器永远不会触发。</p>
<p>您可以将计时器配置为仅一次或重复生成事件。重复计时器会根据计划的触发时间（而不是实际的触发时间）自动重新计划自身。例如，如果计划将计时器在特定时间触发，然后每 5 秒触发一次，则即使实际触发时间被延迟，计划的触发时间也将始终落在原始的 5 秒时间间隔上。如果触发时间延迟得太多，以致错过了一个或多个计划的触发时间，则计时器将在错过的时间段内仅触发一次。在错过了一段时间后触发后，计时器将重新安排为下一个计划的触发时间。</p>
<p>有关配置计时器源的更多信息，请参见“ <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW6">配置计时器源”</a>。有关参考信息，请参见《*<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/timer">NSTimer 类参考》</a>*或《_<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corefoundation/cfrunlooptimer-rhk">CFRunLoopTimer 参考》</a>_。</p>
<h6 id="运行循环观察者"><a href="#运行循环观察者" class="headerlink" title="运行循环观察者"></a>运行循环观察者</h6><p>与在适当的异步或同步事件发生时触发的源相反，运行循环观察者在运行循环本身执行期间的特定位置触发。您可以使用运行循环观察器来准备线程以处理给定事件，或者在线程进入睡眠之前准备线程。您可以将运行循环观察者与运行循环中的以下事件相关联：</p>
<ul>
<li>运行循环的入口。</li>
<li>当运行循环将要处理计时器时。</li>
<li>当运行循环将要处理输入源时。</li>
<li>当运行循环即将进入睡眠状态时。</li>
<li>当运行循环醒来但在处理事件之前将其唤醒。</li>
<li>运行循环的退出。</li>
</ul>
<p>您可以使用 Core Foundation 将运行循环观察器添加到应用程序。要创建运行循环观察器，请创建<code>CFRunLoopObserverRef</code>不透明类型的新实例。此类型跟踪您的自定义回调函数及其感兴趣的活动。</p>
<p>与计时器类似，运行循环观察器可以使用一次或重复使用。一次触发的观察者在触发后将自己从运行循环中删除，而重复的观察者仍保持连接。您可以指定创建观察者时是运行一次还是重复运行。</p>
<p>有关如何创建运行循环观察器的示例，请参见“ <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW18">配置运行循环”</a>。有关参考信息，请参见*<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corefoundation/cfrunloopobserver">CFRunLoopObserver 参考</a>*。</p>
<h6 id="事件的运行循环序列"><a href="#事件的运行循环序列" class="headerlink" title="事件的运行循环序列"></a>事件的运行循环序列</h6><p>每次运行它时，线程的运行循环都会处理未决事件并为任何附加的观察者生成通知。它执行此操作的顺序非常具体，如下所示：</p>
<ol>
<li>通知观察者已进入运行循环。</li>
<li>通知观察者任何准备就绪的计时器即将触发。</li>
<li>通知观察者任何不基于端口的输入源都将被触发。</li>
<li>触发所有准备触发的非基于端口的输入源。</li>
<li>如果基于端口的输入源已准备好并等待启动，请立即处理事件。转到步骤 9。</li>
<li>通知观察者线程即将进入睡眠状态。</li>
<li>使线程进入睡眠状态，直到发生以下事件之一：<ul>
<li>事件到达基于端口的输入源。</li>
<li>计时器触发。</li>
<li>为运行循环设置的超时值到期。</li>
<li>运行循环被明确唤醒。</li>
</ul>
</li>
<li>通知观察者线程刚刚醒来。</li>
<li>处理未决事件。<ul>
<li>如果触发了用户定义的计时器，请处理计时器事件并重新启动循环。转到步骤 2。</li>
<li>如果触发了输入源，则传递事件。</li>
<li>如果运行循环已显式唤醒，但尚未超时，请重新启动循环。转到步骤 2。</li>
</ul>
</li>
<li>通知观察者运行循环已退出。</li>
</ol>
<p>由于计时器和输入源的观察者通知是在这些事件实际发生之前传递的，因此通知时间和实际事件时间之间可能会有差距。如果这些事件之间的时间很关键，则可以使用睡眠和从睡眠中唤醒通知来帮助您关联实际事件之间的时间。</p>
<p>由于在运行运行循环时会传递计时器和其他定期事件，因此规避该循环会中断这些事件的传递。每当您通过进入循环并重复从应用程序请求事件来实现鼠标跟踪例程时，就会出现此行为的典型示例。因为您的代码直接捕获事件，而不是让应用程序正常分配事件，所以活动计时器将无法触发，直到您的鼠标跟踪例程退出并将控制权返回给应用程序为止。</p>
<p>可以使用运行循环对象显式唤醒运行循环。其他事件也可能导致运行循环被唤醒。例如，添加另一个非基于端口的输入源将唤醒运行循环，以便可以立即处理输入源，而不是等到发生其他事件为止。</p>
<h4 id="什么时候使用运行循环？"><a href="#什么时候使用运行循环？" class="headerlink" title="什么时候使用运行循环？"></a>什么时候使用运行循环？</h4><p>唯一需要明确运行运行循环的时间是在为应用程序创建辅助线程时。应用程序主线程的运行循环是基础架构的关键部分。结果，应用程序框架提供了用于运行主应用程序循环并自动启动该循环的代码。在 iOS（或 OS X）<code>run</code>中<code>UIApplication</code>，的方法<code>NSApplication</code>作为正常启动顺序的一部分启动应用程序的主循环。如果使用 Xcode 模板项目创建应用程序，则永远不必显式调用这些例程。</p>
<p>对于辅助线程，您需要确定是否需要运行循环，如果需要，请自行配置并启动它。您无需在所有情况下都启动线程的运行循环。例如，如果您使用线程来执行一些长时间运行且预定的任务，则可以避免启动运行循环。运行循环用于需要与线程更多交互的情况。例如，如果您打算执行以下任一操作，则需要启动运行循环：</p>
<ul>
<li>使用端口或自定义输入源与其他线程进行通信。</li>
<li>在线程上使用计时器。</li>
<li><code>performSelector</code>在 Cocoa 应用程序中使用任何…方法。</li>
<li>保持线程执行定期任务。</li>
</ul>
<p>如果确实选择使用运行循环，则配置和设置非常简单。与所有线程编程一样，您应该有一个计划，在适当的情况下退出辅助线程。最好通过让线程退出干净地结束线程，而不是强制终止线程。<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5">使用运行循环对象中</a>介绍了有关如何配置和退出<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5">运行循环的信息</a>。</p>
<h4 id="使用运行循环对象"><a href="#使用运行循环对象" class="headerlink" title="使用运行循环对象"></a>使用运行循环对象</h4><p>运行循环对象提供了用于将输入源，计时器和运行循环观察器添加到您的运行循环然后运行它的主界面。每个线程都有一个与之关联的运行循环对象。在可可中，此对象是<code>NSRunLoop</code>类的实例。在低级应用程序中，它是指向<code>CFRunLoopRef</code>不透明类型的指针。</p>
<h6 id="获取运行循环对象"><a href="#获取运行循环对象" class="headerlink" title="获取运行循环对象"></a>获取运行循环对象</h6><p>要获取当前线程的运行循环，请使用以下方法之一：</p>
<ul>
<li>在 Cocoa 应用程序中，使用的<code>currentRunLoop</code>类方法<code>NSRunLoop</code>检索<code>NSRunLoop</code>对象。</li>
<li>使用<code>CFRunLoopGetCurrent</code>功能。</li>
</ul>
<p>尽管它们不是免费的桥接类型，但是您可以在需要时<code>CFRunLoopRef</code>从<code>NSRunLoop</code>对象获取不透明类型。本<code>NSRunLoop</code>类定义了一个<code>getCFRunLoop</code>返回的方法<code>CFRunLoopRef</code>类型，你可以传递给 Core Foundation 的例程。由于两个对象都引用相同的运行循环，因此您可以根据需要混合对<code>NSRunLoop</code>对象和<code>CFRunLoopRef</code>不透明类型的调用。</p>
<h6 id="配置运行循环"><a href="#配置运行循环" class="headerlink" title="配置运行循环"></a>配置运行循环</h6><p>在辅助线程上运行运行循环之前，必须向其添加至少一个输入源或计时器。如果运行循环没有任何要监视的源，则当您尝试运行它时，它将立即退出。有关如何将源添加到运行循环的示例，请参见《<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7">配置运行循环源》</a>。</p>
<p>除了安装源代码，您还可以安装运行循环观察器，并使用它们来检测运行循环的不同执行阶段。要安装运行循环观察器，请创建一个<code>CFRunLoopObserverRef</code>不透明类型，然后使用该<code>CFRunLoopAddObserver</code>函数将其添加到您的运行循环中。即使使用 Cocoa 应用程序，也必须使用 Core Foundation 创建运行循环观察器。</p>
<p>清单 3-1 显示了将运行循环观察器附加到其运行循环的线程的主例程。该示例的目的是向您展示如何创建运行循环观察器，因此代码仅设置了一个运行循环观察器以监视所有运行循环活动。基本处理程序例程（未显示）在处理计时器请求时仅记录运行循环活动。</p>
<p><strong>清单 3-1</strong> 创建一个运行循环观察器</p>
<table>
<thead>
<tr>
<th><code>-（无效）threadMain</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//该应用程序使用垃圾回收，因此不需要自动释放池。</code></td>
</tr>
<tr>
<td><code>NSRunLoop * myRunLoop = [NSRunLoop currentRunLoop];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建一个运行循环观察器，并将其附加到运行循环。</code></td>
</tr>
<tr>
<td><code>CFRunLoopObserverContext context = &#123;0，self，NULL，NULL，NULL&#125;;</code></td>
</tr>
<tr>
<td><code>CFRunLoopObserverRef观察者= CFRunLoopObserverCreate（kCFAllocatorDefault，</code></td>
</tr>
<tr>
<td><code>kCFRunLoopAllActivities，是，0，＆myRunLoopObserver，＆context）；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（观察者）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop];</code></td>
</tr>
<tr>
<td><code>CFRunLoopAddObserver（cfLoop，观察者，kCFRunLoopDefaultMode）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建并安排计时器。</code></td>
</tr>
<tr>
<td><code>[NSTimer ScheduledTimerWithTimeInterval：0.1目标：自我</code></td>
</tr>
<tr>
<td><code>选择器：@选择器（doFireTimer ：） userInfo：无重复：是]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>NSInteger loopCount = 10;</code></td>
</tr>
<tr>
<td><code>做</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//运行运行循环10次以使计时器启动。</code></td>
</tr>
<tr>
<td><code>[myRunLoop runUntilDate：[NSDate dateWithTimeIntervalSinceNow：1]];</code></td>
</tr>
<tr>
<td><code>loopCount--;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>while（loopCount）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>为长寿命线程配置运行循环时，最好添加至少一个输入源以接收消息。尽管您可以仅连接一个计时器即可进入运行循环，但是一旦计时器触发，它通常就会失效，这将导致运行循环退出。附加重复计时器可以使运行循环在更长的时间内运行，但是会涉及定期触发计时器以唤醒线程，这实际上是轮询的另一种形式。相比之下，输入源会等待事件发生，使线程保持睡眠状态直到事件发生。</p>
<h6 id="启动运行循环"><a href="#启动运行循环" class="headerlink" title="启动运行循环"></a>启动运行循环</h6><p>仅对于应用程序中的辅助线程，才需要启动运行循环。一个运行循环必须至少有一个输入源或计时器要监视。如果未连接，运行循环将立即退出。</p>
<p>有几种启动运行循环的方法，包括以下几种：</p>
<ul>
<li>无条件</li>
<li>设定时间限制</li>
<li>在特定模式下</li>
</ul>
<p>无条件进入运行循环是最简单的选择，但也是最不希望的。无条件运行运行循环会将线程置于永久循环，这使您几乎无法控制运行循环本身。您可以添加和删除输入源和计时器，但是停止运行循环的唯一方法是终止运行循环。也没有办法在自定义模式下运行运行循环。</p>
<p>与其无条件地运行运行循环，不如使用超时值运行运行循环。当您使用超时值时，运行循环将运行直到事件到达或指定的时间到期为止。如果事件到达，则将该事件调度到处理程序进行处理，然后退出运行循环。然后，您的代码可以重新启动运行循环以处理下一个事件。如果分配的时间到期了，您可以简单地重新启动运行循环或使用该时间进行任何必要的内务处理。</p>
<p>除了超时值之外，您还可以使用特定模式运行运行循环。模式和超时值不是互斥的，并且在启动运行循环时都可以使用。模式限制了将事件传递到运行循环的源的类型，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW12">运行循环模式中</a>对此进行了详细描述。</p>
<p>清单 3-2 显示了线程的主进入例程的框架版本。此示例的关键部分显示了运行循环的基本结构。本质上，您将输入源和计时器添加到运行循环中，然后重复调用例程之一以启动运行循环。每次运行循环例程返回时，您都要检查是否出现了可能保证退出线程的条件。该示例使用 Core Foundation 运行循环例程，以便它可以检查返回结果并确定为什么退出运行循环。<code>NSRunLoop</code>如果您使用的是 Cocoa，并且不需要检查返回值，则也可以使用类的方法以类似的方式运行运行循环。（有关调用<code>NSRunLoop</code>类的方法的运行循环的示例，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW9">清单 3-14</a>。）</p>
<p><strong>清单 3-2</strong> 运行一个运行循环</p>
<table>
<thead>
<tr>
<th><code>-（void）skeletonThreadMain</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//如果不使用垃圾回收，请在此处设置一个自动释放池。</code></td>
</tr>
<tr>
<td><code>BOOL完成=否；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//将您的源代码或计时器添加到运行循环中，然后进行其他任何设置。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>做</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//开始运行循环，但在处理完每个源之后返回。</code></td>
</tr>
<tr>
<td><code>SInt32结果= CFRunLoopRunInMode（kCFRunLoopDefaultMode，10，是）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//如果源明确停止了运行循环，或者没有</code></td>
</tr>
<tr>
<td><code>//来源或计时器，请继续并退出。</code></td>
</tr>
<tr>
<td>`如果（（结果== kCFRunLoopRunStopped）</td>
</tr>
<tr>
<td><code>完成=是;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//在此处检查其他退出条件，并设置</code></td>
</tr>
<tr>
<td><code>//根据需要完成变量。</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>同时（！完成）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//在此处清理代码。确保释放所有分配的自动释放池。</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>可以递归运行运行循环。换句话说，您可以在输入源或计时器的处理程序例程中调用<code>CFRunLoopRun</code>，<code>CFRunLoopRunInMode</code>或任何<code>NSRunLoop</code>用于启动运行循环的方法。这样做时，可以使用任何要运行嵌套运行循环的模式，包括外部运行循环使用的模式。</p>
<h6 id="退出运行循环"><a href="#退出运行循环" class="headerlink" title="退出运行循环"></a>退出运行循环</h6><p>在处理事件之前，有两种方法可以使运行循环退出：</p>
<ul>
<li>配置运行循环以使用超时值运行。</li>
<li>告诉运行循环停止。</li>
</ul>
<p>如果可以管理，使用超时值无疑是首选。指定超时值可使运行循环在退出之前完成其所有正常处理，包括将通知传递给运行循环观察器。</p>
<p>使用该<code>CFRunLoopStop</code>函数显式停止运行循环会产生类似于超时的结果。运行循环将发出所有剩余的运行循环通知，然后退出。区别在于您可以在无条件启动的运行循环中使用此技术。</p>
<p>尽管删除运行循环的输入源和计时器也可能导致运行循环退出，但这不是停止运行循环的可靠方法。一些系统例程将输入源添加到运行循环中以处理所需的事件。因为您的代码可能不知道这些输入源，所以它将无法删除它们，这将阻止运行循环退出。</p>
<h6 id="线程安全和运行循环对象"><a href="#线程安全和运行循环对象" class="headerlink" title="线程安全和运行循环对象"></a>线程安全和运行循环对象</h6><p>线程安全性取决于您用来操纵运行循环的 API。Core Foundation 中的函数通常是线程安全的，可以从任何线程中调用。但是，如果您执行的操作会更改运行循环的配置，则仍然最好从拥有运行循环的线程中进行更改。</p>
<p>可可<code>NSRunLoop</code>类在本质上不如其 Core Foundation 同类线程安全。如果要使用<code>NSRunLoop</code>该类来修改运行循环，则只能从拥有该运行循环的同一线程进行。将输入源或计时器添加到属于不同线程的运行循环中可能会导致代码崩溃或行为异常。</p>
<h4 id="配置运行循环源"><a href="#配置运行循环源" class="headerlink" title="配置运行循环源"></a>配置运行循环源</h4><p>以下各节显示了如何在 Cocoa 和 Core Foundation 中设置不同类型的输入源的示例。</p>
<h6 id="定义自定义输入源"><a href="#定义自定义输入源" class="headerlink" title="定义自定义输入源"></a>定义自定义输入源</h6><p>创建自定义输入源涉及定义以下内容：</p>
<ul>
<li>您希望输入源处理的信息。</li>
<li>调度程序，让感兴趣的客户知道如何联系您的输入源。</li>
<li>处理程序例程，用于执行任何客户端发送的请求。</li>
<li>取消例程使您的输入源无效。</li>
</ul>
<p>因为您创建了一个定制输入源来处理定制信息，所以实际配置被设计为灵活的。调度程序，处理程序和取消例程是自定义输入源几乎始终需要的关键例程。但是，其余大多数输入源行为都发生在那些处理程序例程之外。例如，由您决定定义用于将数据传递到输入源以及将输入源的存在传达给其他线程的机制。</p>
<p>图 3-2 显示了定制输入源的样本配置。在此示例中，应用程序的主线程维护对输入源，该输入源的定制命令缓冲区以及安装该输入源的运行循环的引用。当主线程有一个要移交给工作线程的任务时，它将一个命令以及工作线程启动该任务所需的所有信息发布到命令缓冲区。（由于主线程和工作线程的输入源都可以访问命令缓冲区，因此必须同步该访问。）一旦发布命令，主线程将向输入源发出信号并唤醒工作线程的运行循环。收到唤醒命令后，运行循环将调用输入源的处理程序，该处理程序将处理在命令缓冲区中找到的命令。</p>
<p><strong>图 3-2</strong> 操作自定义输入源<img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt="操作自定义输入源"></p>
<p>以下各节说明了上图中自定义输入源的实现，并显示了您需要实现的关键代码。</p>
<p>######## 定义输入源</p>
<p>定义自定义输入源需要使用 Core Foundation 例程来配置您的运行循环源并将其附加到运行循环。尽管基本处理程序是基于 C 的函数，但这并不妨碍您编写这些函数的包装程序并使用 Objective-C 或 C ++实现代码主体。</p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW31">图 3-2 中</a>引入的输入源使用一个 Objective-C 对象来管理命令缓冲区并与运行循环协调。清单 3-3 显示了此对象的定义。该<code>RunLoopSource</code>对象管理命令缓冲区，并使用该缓冲区从其他线程接收消息。此清单还显示了<code>RunLoopContext</code>对象的定义，它实际上只是一个容器对象，用于传递<code>RunLoopSource</code>对象和对应用程序主线程的运行循环引用。</p>
<p><strong>清单 3-3</strong> 定制输入源对象定义</p>
<table>
<thead>
<tr>
<th><code>@interface RunLoopSource：NSObject</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>CFRunLoopSourceRef runLoopSource;</code></td>
</tr>
<tr>
<td><code>NSMutableArray *命令；</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（id）init;</code></td>
</tr>
<tr>
<td><code>-（void）addToCurrentRunLoop;</code></td>
</tr>
<tr>
<td><code>-（无效）无效；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//处理程序方法</code></td>
</tr>
<tr>
<td><code>-（void）sourceFired;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//客户端接口，用于注册要处理的命令</code></td>
</tr>
<tr>
<td><code>-（void）addCommand：（NSInteger）命令withData：（id）data;</code></td>
</tr>
<tr>
<td><code>-（void）fireAllCommandsOnRunLoop：（CFRunLoopRef）runloop;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>@结束</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//这些是CFRunLoopSourceRef回调函数。</code></td>
</tr>
<tr>
<td><code>void RunLoopSourceScheduleRoutine（void * info，CFRunLoopRef rl，CFStringRef模式）;</code></td>
</tr>
<tr>
<td><code>void RunLoopSourcePerformRoutine（void * info）;</code></td>
</tr>
<tr>
<td><code>void RunLoopSourceCancelRoutine（void * info，CFRunLoopRef rl，CFStringRef模式）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>// RunLoopContext是在输入源注册期间使用的容器对象。</code></td>
</tr>
<tr>
<td><code>@interface RunLoopContext：NSObject</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>CFRunLoopRef runLoop;</code></td>
</tr>
<tr>
<td><code>RunLoopSource *源；</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>@property（只读）CFRunLoopRef runLoop;</code></td>
</tr>
<tr>
<td><code>@property（只读）RunLoopSource *源；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（id）initWithSource：（RunLoopSource *）src和Loop：（CFRunLoopRef）loop;</code></td>
</tr>
<tr>
<td><code>@结束</code></td>
</tr>
</tbody></table>
<p>尽管 Objective-C 代码管理输入源的自定义数据，但是将输入源附加到运行循环需要基于 C 的回调函数。当您将运行循环源实际附加到运行循环时，将调用其中的第一个函数，如清单 3-4 所示。因为此输入源只有一个客户端（主线程），所以它使用调度程序功能发送消息以在该线程上的应用程序委托中注册自己。当委托人想要与输入源进行通信时，它将使用<code>RunLoopContext</code>object 中的信息进行通信。</p>
<p><strong>清单 3-4</strong> 安排运行循环源</p>
<table>
<thead>
<tr>
<th><code>void RunLoopSourceScheduleRoutine（void * info，CFRunLoopRef rl，CFStringRef模式）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>RunLoopSource * obj =（RunLoopSource *）info;</code></td>
</tr>
<tr>
<td><code>AppDelegate * del = [AppDelegate sharedAppDelegate];</code></td>
</tr>
<tr>
<td><code>RunLoopContext * theContext = [[[RunLoopContext alloc] initWithSource：obj和Loop：rl];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[del performSelectorOnMainThread：@selector（registerSource :)</code></td>
</tr>
<tr>
<td><code>withObject：theContext waitUntilDone：NO];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>最重要的回调例程之一是当输入源被信号通知时用于处理自定义数据的例程。清单 3-5 显示了与<code>RunLoopSource</code>对象关联的 perform 回调例程。该功能只是将完成工作的请求转发给<code>sourceFired</code>方法，该方法然后处理命令缓冲区中存在的所有命令。</p>
<p><strong>清单 3-5</strong> 在输入源中执行工作</p>
<table>
<thead>
<tr>
<th><code>void RunLoopSourcePerformRoutine（void * info）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>RunLoopSource * obj =（RunLoopSource *）info;</code></td>
</tr>
<tr>
<td><code>[obj sourceFired];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>如果使用该<code>CFRunLoopSourceInvalidate</code>功能从运行循环中删除输入源，系统将调用输入源的取消例程。您可以使用此例程来通知客户端您的输入源不再有效，并且他们应删除对其的任何引用。 清单 3-6 显示了向该<code>RunLoopSource</code>对象注册的取消回调例程。此函数将另一个<code>RunLoopContext</code>对象发送给应用程序委托，但这一次要求委托删除对运行循环源的引用。</p>
<p><strong>清单 3-6</strong> 使输入源无效</p>
<table>
<thead>
<tr>
<th><code>void RunLoopSourceCancelRoutine（无效* info，CFRunLoopRef rl，CFStringRef模式）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>RunLoopSource * obj =（RunLoopSource *）info;</code></td>
</tr>
<tr>
<td><code>AppDelegate * del = [AppDelegate sharedAppDelegate];</code></td>
</tr>
<tr>
<td><code>RunLoopContext * theContext = [[[RunLoopContext alloc] initWithSource：obj和Loop：rl];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[del performSelectorOnMainThread：@selector（removeSource :)</code></td>
</tr>
<tr>
<td><code>withObject：theContext waitUntilDone：YES];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW37">与输入源的客户端协调中</a>显示 了应用程序委托<code>registerSource:</code>和<code>removeSource:</code>方法<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW37">的代码</a>。</p>
<p>######## 在运行循环上安装输入源</p>
<p>清单 3-7 显示了该类的<code>init</code>和<code>addToCurrentRunLoop</code>方法<code>RunLoopSource</code>。该<code>init</code>方法创建<code>CFRunLoopSourceRef</code>实际上必须附加到运行循环的不透明类型。它将<code>RunLoopSource</code>对象本身作为上下文信息传递，以便回调例程具有指向该对象的指针。在工作线程调用该<code>addToCurrentRunLoop</code>方法之前，不会安装输入源，此时将<code>RunLoopSourceScheduleRoutine</code>调用回调函数。将输入源添加到运行循环后，线程可以运行其运行循环以等待它。</p>
<p><strong>清单 3-7</strong> 安装运行循环源</p>
<table>
<thead>
<tr>
<th><code>-（id）初始化</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>CFRunLoopSourceContext context = &#123;0，self，NULL，NULL，NULL，NULL，NULL，</code></td>
</tr>
<tr>
<td><code>＆RunLoopSourceScheduleRoutine，</code></td>
</tr>
<tr>
<td><code>RunLoopSourceCancelRoutine，</code></td>
</tr>
<tr>
<td><code>RunLoopSourcePerformRoutine&#125;;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>runLoopSource = CFRunLoopSourceCreate（NULL，0，＆context）;</code></td>
</tr>
<tr>
<td><code>命令= [[[NSMutableArray alloc] init];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>返回自我</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（void）addToCurrentRunLoop</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>CFRunLoopRef runLoop = CFRunLoopGetCurrent（）;</code></td>
</tr>
<tr>
<td><code>CFRunLoopAddSource（runLoop，runLoopSource，kCFRunLoopDefaultMode）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>######## 与输入源的客户协调</p>
<p>为了使您的输入源有用，您需要对其进行操作并从另一个线程发出信号。输入源的全部目的是使其关联线程处于休眠状态，直到有事要做。这个事实使得您的应用程序中的其他线程必须了解输入源并有一种与之通信的方法。</p>
<p>通知客户有关您的输入源的一种方法是在您的输入源首次安装在其运行循环中时发出注册请求。您可以向任意数量的客户注册您的输入源，也可以简单地向某个中央机构注册它，然后将您的输入源出售给感兴趣的客户。清单 3-8 显示了由应用程序委托定义的注册方法，该方法在调用<code>RunLoopSource</code>对象的调度程序函数时调用。此方法接收该<code>RunLoopContext</code>对象提供的<code>RunLoopSource</code>对象，并将其添加到其源列表中。此清单还显示了从运行循环中删除输入源时用于注销输入源的例程。</p>
<p><strong>清单 3-8</strong> 使用应用程序委托注册和删除输入源</p>
<table>
<thead>
<tr>
<th><code>-（void）registerSource：（RunLoopContext *）sourceInfo;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>[sourcesToPing addObject：sourceInfo];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>-（无效）removeSource：（RunLoopContext *）sourceInfo</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>id objToRemove = nil;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>用于（SourcesToPing中的RunLoopContext *上下文）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>如果（[context isEqual：sourceInfo]）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>objToRemove =上下文；</code></td>
</tr>
<tr>
<td><code>打破;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（objToRemove）</code></td>
</tr>
<tr>
<td><code>[sourcesToPing removeObject：objToRemove];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW32">清单 3-4</a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW34">清单 3-6</a> 中显示了调用前面清单中的方法的回调函数。</p>
<p>######## 用信号通知输入源</p>
<p>在将其数据交给输入源后，客户端必须向该源发出信号并唤醒其运行循环。向源发出信号会使运行循环知道该源已准备好进行处理。并且由于当信号出现时线程可能处于睡眠状态，因此您应该始终明确地唤醒运行循环。否则，可能会导致输入源处理延迟。</p>
<p>清单 3-9 显示了<code>fireCommandsOnRunLoop</code>该<code>RunLoopSource</code>对象的方法。客户端准备好让源处理它们添加到缓冲区的命令时，客户端将调用此方法。</p>
<p><strong>清单 3-9</strong> 唤醒运行循环</p>
<table>
<thead>
<tr>
<th><code>-（void）fireCommandsOnRunLoop：（CFRunLoopRef）runloop</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>CFRunLoopSourceSignal（runLoopSource）;</code></td>
</tr>
<tr>
<td><code>CFRunLoopWakeUp（runloop）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 永远不要尝试<code>SIGHUP</code>通过传递自定义输入源来处理一个或其他类型的过程级信号。唤醒运行循环的 Core Foundation 函数不是信号安全的，不应在应用程序的信号处理程序例程中使用。有关信号处理程序例程的更多信息，请参见<code>sigaction</code>手册页。</p>
<h6 id="配置计时器源"><a href="#配置计时器源" class="headerlink" title="配置计时器源"></a>配置计时器源</h6><p>要创建计时器源，您要做的就是创建一个计时器对象并将其安排在运行循环中。在 Cocoa 中，您可以使用<code>NSTimer</code>该类来创建新的计时器对象，而在 Core Foundation 中，您可以使用<code>CFRunLoopTimerRef</code>不透明类型。在内部，<code>NSTimer</code>该类只是 Core Foundation 的扩展，提供了一些便利功能，例如使用同一方法创建和安排计时器的功能。</p>
<p>在 Cocoa 中，您可以使用以下两种方法之一同时创建和安排计时器：</p>
<ul>
<li><code>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</code></li>
<li><code>scheduledTimerWithTimeInterval:invocation:repeats:</code></li>
</ul>
<p>这些方法创建计时器并将其以默认模式（<code>NSDefaultRunLoopMode</code>）添加到当前线程的运行循环中。如果需要，还可以通过创建<code>NSTimer</code>对象然后使用的<code>addTimer:forMode:</code>方法将其添加到运行循环中来手动安排计时器<code>NSRunLoop</code>。两种技术基本上都做同样的事情，但是给您对计时器配置的不同级别的控制。例如，如果您创建计时器并将其手动添加到运行循环中，则可以使用默认模式以外的其他模式来执行此操作。清单 3-10 显示了如何使用这两种技术创建计时器。第一个计时器的初始延迟为 1 秒，但此后每隔 0.1 秒定期触发一次。第二个计时器在最初的 0.2 秒延迟后开始触发，然后在此之后每 0.2 秒触发一次。</p>
<p><strong>清单 3-10</strong> 使用 NSTimer 创建和调度计时器</p>
<table>
<thead>
<tr>
<th><code>NSRunLoop * myRunLoop = [NSRunLoop currentRunLoop];</code></th>
</tr>
</thead>
<tbody><tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建并安排第一个计时器。</code></td>
</tr>
<tr>
<td><code>NSDate * futureDate = [NSDate dateWithTimeIntervalSinceNow：1.0];</code></td>
</tr>
<tr>
<td><code>NSTimer * myTimer = [[NSTimer分配] initWithFireDate：futureDate</code></td>
</tr>
<tr>
<td><code>间隔：0.1</code></td>
</tr>
<tr>
<td><code>目标：自我</code></td>
</tr>
<tr>
<td><code>选择器：@选择器（myDoFireTimer1 :)</code></td>
</tr>
<tr>
<td><code>userInfo：无</code></td>
</tr>
<tr>
<td><code>重复：是]；</code></td>
</tr>
<tr>
<td><code>[myRunLoop addTimer：myTimer的模式：NSDefaultRunLoopMode]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建并安排第二个计时器。</code></td>
</tr>
<tr>
<td><code>[NSTimer ScheduledTimerWithTimeInterval：0.2</code></td>
</tr>
<tr>
<td><code>目标：自我</code></td>
</tr>
<tr>
<td><code>选择器：@选择器（myDoFireTimer2 :)</code></td>
</tr>
<tr>
<td><code>userInfo：无</code></td>
</tr>
<tr>
<td><code>重复：是]；</code></td>
</tr>
</tbody></table>
<p>清单 3-11 显示了使用 Core Foundation 函数配置计时器所需的代码。尽管此示例未在上下文结构中传递任何用户定义的信息，但是您可以使用此结构传递计时器所需的任何自定义数据。有关此结构的内容的更多信息，请参见*<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corefoundation/cfrunlooptimer-rhk">CFRunLoopTimer 参考中的</a>*描述。</p>
<p><strong>清单 3-11</strong> 使用 Core Foundation 创建和安排计时器</p>
<table>
<thead>
<tr>
<th><code>CFRunLoopRef runLoop = CFRunLoopGetCurrent（）;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>CFRunLoopTimerContext context = &#123;0，NULL，NULL，NULL，NULL&#125;;</code></td>
</tr>
<tr>
<td><code>CFRunLoopTimerRef timer = CFRunLoopTimerCreate（kCFAllocatorDefault，0.1，0.3，0，0，</code></td>
</tr>
<tr>
<td><code>＆myCFTimerCallback，＆context）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>CFRunLoopAddTimer（runLoop，timer，kCFRunLoopCommonModes）;</code></td>
</tr>
</tbody></table>
<h6 id="配置基于端口的输入源"><a href="#配置基于端口的输入源" class="headerlink" title="配置基于端口的输入源"></a>配置基于端口的输入源</h6><p>Cocoa 和 Core Foundation 都提供了基于端口的对象，用于在线程之间或进程之间进行通信。以下各节说明如何使用几种不同类型的端口来设置端口通信。</p>
<p>######## 配置 NSMachPort 对象</p>
<p>要与<code>NSMachPort</code>对象建立本地连接，请创建端口对象并将其添加到主线程的运行循环中。启动辅助线程时，将同一对象传递给线程的入口点函数。辅助线程可以使用同一对象将消息发送回您的主线程。</p>
<p>########## 实施主线程代码</p>
<p>清单 3-12 显示了用于启动辅助工作线程的主要线程代码。因为 Cocoa 框架执行了许多配置端口和运行循环的干预步骤，所以该<code>launchThread</code>方法明显短于其 Core Foundation 等效方法（<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-139726-BAJBGHHB">清单 3-17</a>）。但是，两者的行为几乎相同。一个区别是，此方法不是将本地端口的名称发送到工作线程，而是<code>NSPort</code>直接发送对象。</p>
<p><strong>清单 3-12</strong> 主线程启动方法</p>
<table>
<thead>
<tr>
<th><code>-（无效）launchThread</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>NSPort * myPort = [NSMachPort端口]；</code></td>
</tr>
<tr>
<td><code>如果（myPort）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//此类处理传入的端口消息。</code></td>
</tr>
<tr>
<td><code>[myPort setDelegate：self];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//将端口安装为当前运行循环上的输入源。</code></td>
</tr>
<tr>
<td><code>[[NSRunLoop currentRunLoop] addPort：myPort forMode：NSDefaultRunLoopMode];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//分离线程。让工作人员释放端口。</code></td>
</tr>
<tr>
<td><code>[NSThread detachNewThreadSelector：@selector（LaunchThreadWithPort :)</code></td>
</tr>
<tr>
<td><code>toTarget：[MyWorkerClass class] withObject：myPort];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>为了在线程之间建立双向通信通道，您可能希望工作线程在签入消息中将其自己的本地端口发送到主线程。接收到签入消息可以使您的主线程知道在启动第二个线程时一切进展顺利，还为您提供了一种向该线程发送更多消息的方法。</p>
<p>清单 3-13 显示<code>handlePortMessage:</code>了主线程的方法。当数据到达线程自己的本地端口时，将调用此方法。当签入消息到达时，该方法直接从端口消息中检索辅助线程的端口，并将其保存以供以后使用。</p>
<p><strong>清单 3-13</strong> 处理 Mach 端口消息</p>
<table>
<thead>
<tr>
<th><code>#define kCheckinMessage 100</code></th>
</tr>
</thead>
<tbody><tr>
<td>``</td>
</tr>
<tr>
<td><code>//处理来自辅助线程的响应。</code></td>
</tr>
<tr>
<td><code>-（void）handlePortMessage：（NSPortMessage *）portMessage</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>unsigned int消息= [portMessage msgid];</code></td>
</tr>
<tr>
<td><code>NSPort * distantPort = nil;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（消息== kCheckinMessage）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//获取辅助线程的通信端口。</code></td>
</tr>
<tr>
<td><code>distantPort = [portMessage sendPort];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//保留并保存工作端口，以备后用。</code></td>
</tr>
<tr>
<td><code>[self storeDistantPort：distantPort];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>其他</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//处理其他消息。</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>########## 实施辅助线程代码</p>
<p>对于辅助工作线程，您必须配置线程并使用指定的端口将信息传递回主线程。</p>
<p>清单 3-14 显示了设置工作线程的代码。在为线程创建自动释放池之后，该方法将创建一个工作器对象以驱动线程执行。worker 对象的<code>sendCheckinMessage:</code>方法（如<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW10">清单 3-15</a>所示）为 worker 线程创建一个本地端口，并将签入消息发送回主线程。</p>
<p><strong>清单 3-14</strong> 使用 Mach 端口启动工作线程</p>
<table>
<thead>
<tr>
<th><code>+（无效）LaunchThreadWithPort：（id）inData</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//设置此线程与主线程之间的连接。</code></td>
</tr>
<tr>
<td><code>NSPort * distantPort =（NSPort *）inData;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>MyWorkerClass * workerObj = [[self alloc] init];</code></td>
</tr>
<tr>
<td><code>[workerObj sendCheckinMessage：distantPort];</code></td>
</tr>
<tr>
<td><code>[distantPort版本]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//让运行循环处理事物。</code></td>
</tr>
<tr>
<td><code>做</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>[[NSRunLoop currentRunLoop] runMode：NSDefaultRunLoopMode</code></td>
</tr>
<tr>
<td><code>beforeDate：[NSDate distantFuture]];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>while（！[workerObj shouldExit]）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[workerObj发布]；</code></td>
</tr>
<tr>
<td><code>[池释放];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>使用时<code>NSMachPort</code>，本地线程和远程线程可以将相同的端口对象用于线程之间的单向通信。换句话说，一个线程创建的本地端口对象成为另一线程的远程端口对象。</p>
<p>清单 3-15 显示了辅助线程的签入例程。此方法设置自己的本地端口以用于将来的通信，然后将签入消息发送回主线程。该方法将方法中接收到的端口对象<code>LaunchThreadWithPort:</code>用作消息的目标。</p>
<p><strong>清单 3-15</strong> 使用 Mach 端口发送签入消息</p>
<table>
<thead>
<tr>
<th><code>//工作线程签入方法</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>-（void）sendCheckinMessage：（NSPort *）outPort</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//保留并保存远程端口以备将来使用。</code></td>
</tr>
<tr>
<td><code>[self setRemotePort：outPort];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建并配置工作线程端口。</code></td>
</tr>
<tr>
<td><code>NSPort * myPort = [NSMachPort端口]；</code></td>
</tr>
<tr>
<td><code>[myPort setDelegate：self];</code></td>
</tr>
<tr>
<td><code>[[NSRunLoop currentRunLoop] addPort：myPort forMode：NSDefaultRunLoopMode];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建签到消息。</code></td>
</tr>
<tr>
<td><code>NSPortMessage * messageObj = [[NSPortMessage alloc] initWithSendPort：outPort</code></td>
</tr>
<tr>
<td><code>receivePort：myPort组件：无]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（messageObj）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//完成消息配置并立即发送。</code></td>
</tr>
<tr>
<td><code>[messageObj setMsgId：setMsgid：kCheckinMessage]；</code></td>
</tr>
<tr>
<td><code>[messageObj sendBeforeDate：[NSDate date]]；</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>######## 配置 NSMessagePort 对象</p>
<p>要与<code>NSMessagePort</code>对象建立本地连接，不能简单地在线程之间传递端口对象。远程消息端口必须按名称获取。要在 Cocoa 中实现此功能，需要使用特定名称注册您的本地端口，然后将该名称传递给远程线程，以便它可以获得用于通信的适当端口对象。清单 3-16 显示了要使用消息端口的情况下的端口创建和注册过程。</p>
<p><strong>清单 3-16</strong> 注册消息端口</p>
<table>
<thead>
<tr>
<th><code>NSPort * localPort = [[NSMessagePort alloc] init];</code></th>
</tr>
</thead>
<tbody><tr>
<td>``</td>
</tr>
<tr>
<td><code>//配置对象并将其添加到当前运行循环中。</code></td>
</tr>
<tr>
<td><code>[localPort setDelegate：self];</code></td>
</tr>
<tr>
<td><code>[[NSRunLoop currentRunLoop] addPort：localPort forMode：NSDefaultRunLoopMode];</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//使用特定名称注册端口。名称必须唯一。</code></td>
</tr>
<tr>
<td><code>NSString * localPortName = [NSString stringWithFormat：@“ MyPortName”];</code></td>
</tr>
<tr>
<td><code>[[NSMessagePortNameServer sharedInstance] registerPort：localPort</code></td>
</tr>
<tr>
<td><code>name：localPortName];</code></td>
</tr>
</tbody></table>
<p>######## 在 Core Foundation 中配置基于端口的输入源</p>
<p>本节说明如何使用 Core Foundation 在应用程序的主线程和辅助线程之间建立双向通信通道。</p>
<p>清单 3-17 显示了由应用程序的主线程调用以启动工作线程的代码。代码要做的第一件事是建立一个<code>CFMessagePortRef</code>不透明类型，以侦听来自工作线程的消息。工作线程需要使用端口名称进行连接，以便将字符串值传递到工作线程的入口点函数。在当前用户上下文中，端口名称通常应该是唯一的；否则，您可能会遇到冲突。</p>
<p><strong>清单 3-17</strong> 将 Core Foundation 消息端口附加到新线程</p>
<table>
<thead>
<tr>
<th><code>＃定义kThreadStackSize（8 * 4096）</code></th>
</tr>
</thead>
<tbody><tr>
<td>``</td>
</tr>
<tr>
<td><code>OSStatus MySpawnThread（）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//创建一个本地端口以接收响应。</code></td>
</tr>
<tr>
<td><code>CFStringRef myPortName;</code></td>
</tr>
<tr>
<td><code>CFMessagePortRef myPort;</code></td>
</tr>
<tr>
<td><code>CFRunLoopSourceRef rlSource;</code></td>
</tr>
<tr>
<td><code>CFMessagePortContext context = &#123;0，NULL，NULL，NULL，NULL&#125;;</code></td>
</tr>
<tr>
<td><code>布尔值shouldFreeInfo;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//用端口名创建一个字符串。</code></td>
</tr>
<tr>
<td><code>myPortName = CFStringCreateWithFormat（NULL，NULL，CFSTR（“ com.myapp.MainThread”））;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建端口。</code></td>
</tr>
<tr>
<td><code>myPort = CFMessagePortCreateLocal（NULL，</code></td>
</tr>
<tr>
<td><code>myPortName，</code></td>
</tr>
<tr>
<td><code>＆MainThreadResponseHandler，</code></td>
</tr>
<tr>
<td><code>＆context，</code></td>
</tr>
<tr>
<td><code>＆shouldFreeInfo）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（myPort！= NULL）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//端口已成功创建。</code></td>
</tr>
<tr>
<td><code>//现在为其创建一个运行循环源。</code></td>
</tr>
<tr>
<td><code>rlSource = CFMessagePortCreateRunLoopSource（NULL，myPort，0）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（rlSource）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//将源添加到当前的运行循环中。</code></td>
</tr>
<tr>
<td><code>CFRunLoopAddSource（CFRunLoopGetCurrent（），rlSource，kCFRunLoopDefaultMode）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//一旦安装，就可以释放它们。</code></td>
</tr>
<tr>
<td><code>CFRelease（myPort）;</code></td>
</tr>
<tr>
<td><code>CFRelease（rlSource）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//创建线程并继续处理。</code></td>
</tr>
<tr>
<td><code>MPTaskID taskID;</code></td>
</tr>
<tr>
<td><code>return（MPCreateTask（＆ServerThreadEntryPoint，</code></td>
</tr>
<tr>
<td><code>（void *）myPortName，</code></td>
</tr>
<tr>
<td><code>kThreadStackSize，</code></td>
</tr>
<tr>
<td><code>空值，</code></td>
</tr>
<tr>
<td><code>空值，</code></td>
</tr>
<tr>
<td><code>空值，</code></td>
</tr>
<tr>
<td><code>0，</code></td>
</tr>
<tr>
<td><code>＆taskID））;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>安装端口并启动线程后，主线程可以在等待线程检入的同时继续其常规执行。当检入消息到达时，它将分派给主线程的<code>MainThreadResponseHandler</code>函数，如清单 3-18 所示。。此函数提取工作线程的端口名，并创建用于将来通信的管道。</p>
<p><strong>清单 3-18</strong> 接收签入消息</p>
<table>
<thead>
<tr>
<th><code>#define kCheckinMessage 100</code></th>
</tr>
</thead>
<tbody><tr>
<td>``</td>
</tr>
<tr>
<td><code>//主线程端口消息处理程序</code></td>
</tr>
<tr>
<td><code>CFDataRef MainThreadResponseHandler（CFMessagePortRef local，</code></td>
</tr>
<tr>
<td><code>SInt32 msgid，</code></td>
</tr>
<tr>
<td><code>CFDataRef数据，</code></td>
</tr>
<tr>
<td><code>无效*信息）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>如果（msgid == kCheckinMessage）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>CFMessagePortRef messagePort;</code></td>
</tr>
<tr>
<td><code>CFStringRef threadPortName;</code></td>
</tr>
<tr>
<td><code>CFIndex bufferLength = CFDataGetLength（data）;</code></td>
</tr>
<tr>
<td><code>UInt8 * buffer = CFAllocatorAllocate（NULL，bufferLength，0）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>CFDataGetBytes（data，CFRangeMake（0，bufferLength），buffer）;</code></td>
</tr>
<tr>
<td><code>threadPortName = CFStringCreateWithBytes（NULL，buffer，bufferLength，kCFStringEncodingASCII，FALSE）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//您必须按名称获取远程消息端口。</code></td>
</tr>
<tr>
<td><code>messagePort = CFMessagePortCreateRemote（NULL，（CFStringRef）threadPortName）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（messagePort）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//保留并保存线程的通讯端口，以备将来参考。</code></td>
</tr>
<tr>
<td><code>AddPortToListOfActiveThreads（messagePort）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//由于该端口由上一个函数保留，因此释放</code></td>
</tr>
<tr>
<td><code>// 在这里。</code></td>
</tr>
<tr>
<td><code>CFRelease（messagePort）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>// 清理。</code></td>
</tr>
<tr>
<td><code>CFRelease（threadPortName）;</code></td>
</tr>
<tr>
<td><code>CFAllocatorDeallocate（NULL，buffer）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>其他</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//处理其他消息。</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>返回NULL;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>配置了主线程后，剩下的唯一事情就是新创建的工作线程创建自己的端口并签入。清单 3-19 显示了工作线程的入口点函数。该函数提取主线程的端口名，并使用它来创建返回到主线程的远程连接。然后，该函数为其自身创建一个本地端口，将该端口安装在线程的运行循环上，并向主线程发送包含本地端口名称的签入消息。</p>
<p><strong>清单 3-19</strong> 设置线程结构</p>
<table>
<thead>
<tr>
<th><code>OSStatus ServerThreadEntryPoint（void *参数）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//创建到主线程的远程端口。</code></td>
</tr>
<tr>
<td><code>CFMessagePortRef mainThreadPort;</code></td>
</tr>
<tr>
<td><code>CFStringRef portName =（CFStringRef）param;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>mainThreadPort = CFMessagePortCreateRemote（NULL，portName）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//释放在参数中传递的字符串。</code></td>
</tr>
<tr>
<td><code>CFRelease（端口名）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//为工作线程创建一个端口。</code></td>
</tr>
<tr>
<td><code>CFStringRef myPortName = CFStringCreateWithFormat（NULL，NULL，CFSTR（“ com.MyApp.Thread-％d”），MPCurrentTaskID（））;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//将端口存储在此线程的上下文信息中，以供以后参考。</code></td>
</tr>
<tr>
<td><code>CFMessagePortContext context = &#123;0，mainThreadPort，NULL，NULL，NULL&#125;;</code></td>
</tr>
<tr>
<td><code>布尔值shouldFreeInfo;</code></td>
</tr>
<tr>
<td><code>布尔值shouldAbort = TRUE;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>CFMessagePortRef myPort = CFMessagePortCreateLocal（NULL，</code></td>
</tr>
<tr>
<td><code>myPortName，</code></td>
</tr>
<tr>
<td><code>＆ProcessClientRequest，</code></td>
</tr>
<tr>
<td><code>＆context，</code></td>
</tr>
<tr>
<td><code>＆shouldFreeInfo）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>如果（shouldFreeInfo）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//无法创建本地端口，因此请终止线程。</code></td>
</tr>
<tr>
<td><code>MPExit（0）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>CFRunLoopSourceRef rlSource = CFMessagePortCreateRunLoopSource（NULL，myPort，0）;</code></td>
</tr>
<tr>
<td><code>如果（！rlSource）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//无法创建本地端口，因此请终止线程。</code></td>
</tr>
<tr>
<td><code>MPExit（0）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//将源添加到当前的运行循环中。</code></td>
</tr>
<tr>
<td><code>CFRunLoopAddSource（CFRunLoopGetCurrent（），rlSource，kCFRunLoopDefaultMode）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//一旦安装，就可以释放它们。</code></td>
</tr>
<tr>
<td><code>CFRelease（myPort）;</code></td>
</tr>
<tr>
<td><code>CFRelease（rlSource）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//打包端口名称并发送签入消息。</code></td>
</tr>
<tr>
<td><code>CFDataRef returnData = nil;</code></td>
</tr>
<tr>
<td><code>CFDataRef outData;</code></td>
</tr>
<tr>
<td><code>CFIndex stringLength = CFStringGetLength（myPortName）;</code></td>
</tr>
<tr>
<td><code>UInt8 * buffer = CFAllocatorAllocate（NULL，stringLength，0）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>CFStringGetBytes（myPortName，</code></td>
</tr>
<tr>
<td><code>CFRangeMake（0，stringLength），</code></td>
</tr>
<tr>
<td><code>kCFStringEncodingASCII，</code></td>
</tr>
<tr>
<td><code>0，</code></td>
</tr>
<tr>
<td><code>假，</code></td>
</tr>
<tr>
<td><code>缓冲，</code></td>
</tr>
<tr>
<td><code>stringLength，</code></td>
</tr>
<tr>
<td><code>空值）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>outData = CFDataCreate（NULL，buffer，stringLength）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>CFMessagePortSendRequest（mainThreadPort，kCheckinMessage，outData，0.1，0.0，NULL，NULL）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//清理线程数据结构。</code></td>
</tr>
<tr>
<td><code>CFRelease（outData）;</code></td>
</tr>
<tr>
<td><code>CFAllocatorDeallocate（NULL，buffer）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//进入运行循环。</code></td>
</tr>
<tr>
<td><code>CFRunLoopRun（）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>一旦进入运行循环，该<code>ProcessClientRequest</code>函数将处理所有将来发送到线程端口的事件。该函数的实现取决于线程执行的工作类型，此处未显示。</p>
<h2 id="同步化"><a href="#同步化" class="headerlink" title="同步化"></a>同步化</h2><p>应用程序中存在多个线程带来了与从多个执行线程安全访问资源有关的潜在问题。修改同一资源的两个线程可能会以意想不到的方式相互干扰。例如，一个线程可能会覆盖另一个线程的更改，或者将应用程序置于未知且可能无效的状态。如果幸运的话，损坏的资源可能会导致明显的性能问题或崩溃，这些问题相对容易跟踪和修复。但是，如果您不走运，损坏可能会导致细微的错误，直到很久以后才会显现出来，或者这些错误可能需要对基础的编码假设进行重大检查。</p>
<p>在线程安全方面，好的设计是您拥有的最佳保护。避免共享资源并最小化线程之间的交互，使这些线程相互干扰的可能性降低。但是，并非总是可以实现完全无干扰的设计。如果您的线程必须进行交互，则需要使用同步工具来确保它们在交互时安全地进行交互。</p>
<p>OS X 和 iOS 提供了许多同步工具供您使用，从提供互斥访问的工具到在应用程序中正确排序事件的工具。以下各节描述了这些工具以及如何在代码中使用它们以影响对程序资源的安全访问。</p>
<h4 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h4><p>为了防止不同的线程意外更改数据，可以将应用程序设计为不存在同步问题，也可以使用同步工具。尽管最好完全避免同步问题，但这并不总是可能的。以下各节介绍了可供您使用的同步工具的基本类别。</p>
<h6 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h6><p>原子操作是一种简单的同步形式，适用于简单的数据类型。原子操作的优点是它们不会阻塞竞争线程。对于简单的操作（例如增加计数器变量），这比使用锁可以带来更好的性能。</p>
<p>OS X 和 iOS 包含许多操作，可以对 32 位和 64 位值执行基本的数学和逻辑运算。这些操作包括比较和交换，测试和设置以及测试和清除操作的原子版本。有关受支持的原子操作的列表，请参见<code>/usr/include/libkern/OSAtomic.h</code>头文件或<code>atomic</code>手册页。</p>
<h6 id="内存壁垒和易失性变量"><a href="#内存壁垒和易失性变量" class="headerlink" title="内存壁垒和易失性变量"></a>内存壁垒和易失性变量</h6><p>为了获得最佳性能，编译器经常对汇编级指令进行重新排序，以使处理器的指令流水线尽可能完整。作为此优化的一部分，当编译器认为这样做不会产生不正确的数据时，可能会对访问主内存的指令进行重新排序。不幸的是，编译器并非总是能够检测到所有与内存相关的操作。如果看似独立的变量实际上相互影响，则编译器优化可能会以错误的顺序更新这些变量，从而产生可能不正确的结果。</p>
<p>内存屏障是一种非阻塞同步工具，用于确保内存操作以正确的顺序发生。内存屏障的作用类似于围栏，迫使处理器在允许执行位于屏障之后的加载和存储操作之前，完成位于屏障前面的所有加载和存储操作。内存屏障通常用于确保一个线程（但另一线程可见）的内存操作始终按预期的顺序发生。在这种情况下缺少内存屏障可能会使其他线程看到看似不可能的结果。（有关示例，请参阅 Wikipedia 条目中的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Memory_barrier">内存障碍</a>。）要使用内存障碍，只需<code>OSMemoryBarrier</code>在代码中的适当位置调用该函数。</p>
<p>易失性变量将另一种类型的内存约束应用于单个变量。编译器通常通过将变量的值加载到寄存器中来优化代码。对于局部变量，这通常不是问题。但是，如果从另一个线程可见该变量，则这种优化可能会阻止另一个线程注意到对该变量的任何更改。将<code>volatile</code>关键字应用于变量会强制编译器每次使用时从内存中加载该变量。您可以声明一个变量，<code>volatile</code>好像它的值可以随时被编译器可能无法检测到的外部源更改一样。</p>
<p>由于内存屏障和易失性变量都减少了编译器可执行的优化次数，因此应谨慎使用它们，并且仅在需要确保正确性的地方使用它们。有关使用内存屏障的信息，请参见 <code>OSMemoryBarrier</code>手册页。</p>
<h6 id="锁具"><a href="#锁具" class="headerlink" title="锁具"></a>锁具</h6><p>锁是最常用的同步工具之一。您可以使用锁来保护代码的<em>关键部分</em>，这是一段代码，一次只能允许一个线程访问。例如，关键部分可能操纵特定的数据结构或一次使用最多支持一个客户端的某些资源。通过在此部分周围加锁，可以排除其他线程进行可能影响代码正确性的更改。</p>
<p>表 4-1 列出了程序员常用的一些锁。OS X 和 iOS 提供了大多数此类锁类型的实现，但并非全部。对于不受支持的锁类型，描述列说明了未在平台上直接实现这些锁的原因。</p>
<table>
<thead>
<tr>
<th align="left">锁</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">互斥体</td>
<td align="left">互斥（或<em>互斥</em>）锁充当资源周围的保护性屏障。互斥锁是一种信号量，它一次只能授予对一个线程的访问权限。如果正在使用互斥锁，而另一个线程试图获取该互斥锁，则该线程将阻塞，直到该互斥锁被其原始持有者释放为止。如果多个线程竞争同一个互斥锁，则一次只能访问一个。</td>
</tr>
<tr>
<td align="left">递归锁</td>
<td align="left">递归锁是互斥锁的一种变体。递归锁允许单个线程在释放它之前多次获取该锁。其他线程将保持阻塞状态，直到锁的所有者以与获取锁相同的次数释放锁。递归锁主要在递归迭代期间使用，但也可以在多个方法各自需要分别获取锁的情况下使用。</td>
</tr>
<tr>
<td align="left">读写锁</td>
<td align="left">读写锁也称为共享独占锁。这种类型的锁通常用于较大规模的操作，如果经常读取受保护的数据结构并仅偶尔进行修改，则可以显着提高性能。在正常操作期间，多个读取器可以同时访问数据结构。但是，当线程要写入结构时，它将阻塞，直到所有读取器都释放锁为止，此时，它获取了锁并可以更新结构。当写入线程正在等待锁定时，新的读取器线程将阻塞，直到写入线程完成。系统仅支持使用 POSIX 线程的读写锁。有关如何使用这些锁的更多信息，请参见<code>pthread</code>手册页。</td>
</tr>
<tr>
<td align="left">分布式锁</td>
<td align="left">分布式锁在进程级别提供互斥访问。与真正的互斥锁不同，分布式锁不会阻止进程或阻止其运行。它仅报告锁何时繁忙，并让进程决定如何进行。</td>
</tr>
<tr>
<td align="left">自旋锁</td>
<td align="left">自旋锁反复轮询其锁定条件，直到该条件变为 true。自旋锁最常用于多处理器系统，其中锁的预期等待时间很小。在这些情况下，轮询通常比阻塞线程更有效，这需要上下文切换和线程数据结构的更新。由于它们具有轮询性质，因此系统不提供自旋锁的任何实现，但是您可以在特定情况下轻松地实现它们。有关在内核中实现自旋锁的信息，请参见《_<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905">内核编程指南》</a>_。</td>
</tr>
<tr>
<td align="left">双重检查锁</td>
<td align="left">双重检查锁是通过在获取锁之前测试锁定条件来减少获取锁的开销的尝试。由于双重检查的锁可能不安全，因此系统不会为它们提供明确的支持，因此不建议使用它们。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 大多数类型的锁还包含一个内存屏障，以确保在进入关键部分之前完成所有先前的装载和存储指令。</p>
<p>有关如何使用锁的信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW16">使用锁</a>。</p>
<h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><p>条件是信号量的另一种类型，当某个条件为真时，它允许线程彼此发信号。条件通常用于指示资源的可用性或确保任务以特定顺序执行。当线程测试条件时，除非该条件已经为真，否则它将阻塞。它保持阻塞状态，直到其他线程显式更改并发出条件信号为止。条件和互斥锁之间的区别在于，可以允许多个线程同时访问该条件。条件更多是看门人，它根据某些指定的标准让不同的线程通过门。</p>
<p>使用条件的一种方法是管理未决事件池。当事件队列中有事件时，事件队列将使用条件变量来通知等待线程。如果一个事件到达，则队列将适当地发出条件信号。如果一个线程已经在等待，它将被唤醒，随后它将把事件从队列中拉出并进行处理。如果两个事件几乎同时进入队列，则队列将两次发出信号通知状态以唤醒两个线程。</p>
<p>该系统为几种不同技术的条件提供支持。条件的正确实现需要仔细的编码，因此，在将其用于自己的代码之前，应先查看“ <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW4">使用条件”</a>中的示例。</p>
<h6 id="执行选择器例程"><a href="#执行选择器例程" class="headerlink" title="执行选择器例程"></a>执行选择器例程</h6><p>可可应用程序具有一种以同步方式将消息传递到单个线程的便捷方法。在<code>NSObject</code>类声明对应用程序的活动线程的一个进行选择的方法。这些方法使您的线程可以异步传递消息，并确保它们将由目标线程同步执行。例如，您可以使用执行选择器消息将结果从分布式计算传递到应用程序的主线程或指定的协调器线程。每个执行选择器的请求都在目标线程的运行循环中排队，然后按照接收顺序对请求进行顺序处理。</p>
<p>有关执行选择器例程的摘要以及有关如何使用它们的更多信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW44">Cocoa Perform Selector Sources</a>。</p>
<h4 id="同步成本和性能"><a href="#同步成本和性能" class="headerlink" title="同步成本和性能"></a>同步成本和性能</h4><p>同步有助于确保代码的正确性，但这样做会牺牲性能。即使在无争议的情况下，使用同步工具也会带来延迟。锁和原子操作通常涉及内存屏障和内核级同步的使用，以确保代码得到适当的保护。如果存在争用锁的情况，您的线程可能会阻塞并经历更大的延迟。</p>
<p>表 4-2 列出了在无争议的情况下与互斥锁和原子操作相关的一些近似成本。这些测量值代表了数千个样本的平均时间。但是，与线程创建时间一样，互斥锁获取时间（即使在无争议的情况下）也可能因处理器负载，计算机速度以及可用系统和程序内存量的不同而有很大差异。</p>
<table>
<thead>
<tr>
<th align="left">项目</th>
<th align="left">大概费用</th>
<th align="left">笔记</th>
</tr>
</thead>
<tbody><tr>
<td align="left">互斥体获取时间</td>
<td align="left">约 0.2 微秒</td>
<td align="left">这是无争议情况下的锁获取时间。如果该锁由另一个线程持有，则获取时间可能会更长。这些数字是通过分析在基于 Intel 的 iMac（具有 2 GHz Core Duo 处理器和 1 GB 运行 OS X v10.5 的 RAM）上的互斥锁获取期间生成的平均值和中值确定的。</td>
</tr>
<tr>
<td align="left">原子比较和交换</td>
<td align="left">约 0.05 微秒</td>
<td align="left">这是无争议情况下的比较和交换时间。这些数字是通过分析操作的平均值和中值确定的，是在基于 Intel 的 iMac 上生成的，该 iMac 具有 2 GHz Core Duo 处理器和 1 GB 运行 OS X v10.5 的 RAM。</td>
</tr>
</tbody></table>
<p>在设计并发任务时，正确性始终是最重要的因素，但是您也应该考虑性能因素。在多个线程下可以正确执行的代码，但是比在单个线程上运行的相同代码慢的代码，几乎没有改进。</p>
<p>如果要翻新现有的单线程应用程序，则应始终对关键任务的性能进行一组基准测量。添加其他线程后，您应该对这些相同的任务进行新的测量，并将多线程案例与单线程案例的性能进行比较。如果在调整代码后，线程无法提高性能，则您可能需要重新考虑您的特定实现或线程的使用。</p>
<p>有关性能和用于收集指标的工具的信息，请参阅*<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410">性能概述</a>*。有关锁和原子操作成本的特定信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7">线程成本</a>。</p>
<h4 id="线程安全和信号"><a href="#线程安全和信号" class="headerlink" title="线程安全和信号"></a>线程安全和信号</h4><p>对于线程化应用程序，没有什么比处理信号问题引起更多的恐惧或困惑了。信号是一种低级 BSD 机制，可用于将信息传递给流程或以某种方式操纵它。一些程序使用信号来检测某些事件，例如子进程的死亡。系统使用信号终止失控过程并传达其他类型的信息。</p>
<p>信号的问题不是它们的作用，而是应用程序具有多个线程时的行为。在单线程应用程序中，所有信号处理程序都在主线程上运行。在多线程应用程序中，与特定硬件错误（例如非法指令）无关的信号会传递到当时正在运行的任何线程。如果同时运行多个线程，则将信号传递给系统碰巧的任何一个。换句话说，信号可以传递到应用程序的任何线程。</p>
<p>在应用程序中实现信号处理程序的第一条规则是避免假设哪个线程正在处理信号。如果特定线程要处理给定的信号，则需要制定某种方法在信号到达时通知该线程。您不能仅仅假设从该线程安装信号处理程序将导致信号传递到同一线程。</p>
<p>有关信号和安装信号处理程序的更多信息，请参见<code>signal</code>和<code>sigaction</code>手册页。</p>
<h4 id="线程安全设计的提示"><a href="#线程安全设计的提示" class="headerlink" title="线程安全设计的提示"></a>线程安全设计的提示</h4><p>同步工具是使代码线程安全的一种有用方法，但不是万能药。与非线程性能相比，使用过多的锁和其他类型的同步原语实际上会降低应用程序的线程性能。在安全和性能之间找到合适的平衡是一门需要经验的艺术。以下各节提供了一些技巧，以帮助您为应用程序选择适当的同步级别。</p>
<h6 id="完全避免同步"><a href="#完全避免同步" class="headerlink" title="完全避免同步"></a>完全避免同步</h6><p>对于您正在从事的任何新项目，甚至对于现有项目，设计代码和数据结构来避免需要同步都是最佳的解决方案。尽管锁和其他同步工具很有用，但它们确实会影响任何应用程序的性能。而且，如果总体设计导致特定资源之间的争用较高，则您的线程可能会等待更长的时间。</p>
<p>实施并发的最佳方法是减少并发任务之间的交互和相互依赖性。如果每个任务都在其自己的私有数据集上运行，则无需使用锁来保护该数据。即使在两个任务确实共享一个公共数据集的情况下，您也可以查看对该集进行分区的方式或为每个任务提供自己的副本。当然，复制数据集也有其成本，因此在做出决定之前，您必须权衡这些成本和同步成本。</p>
<h6 id="了解同步的局限性"><a href="#了解同步的局限性" class="headerlink" title="了解同步的局限性"></a>了解同步的局限性</h6><p>同步工具仅在应用程序中的所有线程一致使用时才有效。如果创建互斥量以限制对特定资源的访问，则所有线程在尝试操作该资源之前必须获取相同的互斥量。否则会破坏互斥锁提供的保护，这是程序员的错误。</p>
<h6 id="注意代码正确性的威胁"><a href="#注意代码正确性的威胁" class="headerlink" title="注意代码正确性的威胁"></a>注意代码正确性的威胁</h6><p>使用锁和内存屏障时，应始终仔细考虑它们在代码中的位置。即使是看似位置正确的锁，实际上也会使您陷入一种错误的安全感。以下一系列示例试图通过指出看似无害的代码中的缺陷来说明这个问题。基本前提是您具有一个包含一组不可变对象的可变数组。假设您要调用数组中第一个对象的方法。您可以使用以下代码进行操作：</p>
<table>
<thead>
<tr>
<th><code>NSLock * arrayLock = GetArrayLock（）;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>NSMutableArray * myArray = GetSharedArray（）;</code></td>
</tr>
<tr>
<td><code>id anObject;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[arrayLock锁];</code></td>
</tr>
<tr>
<td><code>anObject = [myArray objectAtIndex：0];</code></td>
</tr>
<tr>
<td><code>[arrayLock解锁]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[anObject doSomething];</code></td>
</tr>
</tbody></table>
<p>由于数组是可变的，因此数组周围的锁可防止其他线程修改数组，直到获得所需的对象为止。并且由于您检索的对象本身是不可变的，因此在<code>doSomething</code>方法调用周围不需要锁定。</p>
<p>但是，前面的示例存在问题。如果释放锁并有另一个线程进入并从数组中删除所有对象，然后才有可能执行该<code>doSomething</code>方法，会发生什么？在没有垃圾回收的应用程序中，可以释放代码所持有的对象，而<code>anObject</code>指向无效的内存地址。要解决此问题，您可以决定简单地重新排列现有代码，并在调用后释放锁<code>doSomething</code>，如下所示：</p>
<table>
<thead>
<tr>
<th><code>NSLock * arrayLock = GetArrayLock（）;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>NSMutableArray * myArray = GetSharedArray（）;</code></td>
</tr>
<tr>
<td><code>id anObject;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[arrayLock锁];</code></td>
</tr>
<tr>
<td><code>anObject = [myArray objectAtIndex：0];</code></td>
</tr>
<tr>
<td><code>[anObject doSomething];</code></td>
</tr>
<tr>
<td><code>[arrayLock解锁]；</code></td>
</tr>
</tbody></table>
<p>通过<code>doSomething</code>在锁内移动调用，您的代码可确保在调用该方法时该对象仍然有效。不幸的是，如果该<code>doSomething</code>方法需要很长时间才能执行，则可能导致您的代码长时间保持锁定，从而可能导致性能瓶颈。</p>
<p>代码的问题不是关键区域定义不正确，而是实际问题未被理解。真正的问题是仅由其他线程的存在触发的内存管理问题。因为它可以被另一个线程释放，所以更好的解决方案是<code>anObject</code>在释放锁之前保留它。该解决方案解决了对象被释放的实际问题，并且这样做不会造成潜在的性能损失。</p>
<table>
<thead>
<tr>
<th><code>NSLock * arrayLock = GetArrayLock（）;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>NSMutableArray * myArray = GetSharedArray（）;</code></td>
</tr>
<tr>
<td><code>id anObject;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[arrayLock锁];</code></td>
</tr>
<tr>
<td><code>anObject = [myArray objectAtIndex：0];</code></td>
</tr>
<tr>
<td><code>[anObject保留]；</code></td>
</tr>
<tr>
<td><code>[arrayLock解锁]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[anObject doSomething];</code></td>
</tr>
<tr>
<td><code>[anObject版本]；</code></td>
</tr>
</tbody></table>
<p>尽管以上示例本质上非常简单，但是它们确实说明了非常重要的一点。当涉及到正确性时，您必须超越明显的问题进行思考。内存管理和设计的其他方面也可能会受到多个线程的影响，因此您必须预先考虑这些问题。另外，您应该始终假设编译器在安全方面会做最坏的事情。这种了解和警惕应有助于您避免潜在的问题，并确保您的代码正常运行。</p>
<p>有关如何使程序具有线程安全性的其他示例，请参见“ <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1">线程安全性摘要”</a>。</p>
<h6 id="当心死锁和活锁"><a href="#当心死锁和活锁" class="headerlink" title="当心死锁和活锁"></a>当心死锁和活锁</h6><p>每当线程尝试同时获取多个锁时，都有可能发生死锁。当两个不同的线程持有另一个线程需要的锁，然后尝试获取另一个线程持有的锁时，就会发生死锁。结果是每个线程都永久阻塞，因为它永远无法获取另一个锁。</p>
<p>活动锁类似于死锁，当两个线程竞争同一组资源时发生。在活动锁情况下，线程放弃其第一把锁，以尝试获取其第二把锁。一旦获得第二个锁，它将返回并尝试再次获取第一个锁。它之所以锁定，是因为它花费了所有时间释放一个锁并试图获取另一个锁，而不是进行任何实际工作。</p>
<p>避免出现死锁和活锁情况的最佳方法是一次只锁定一个。如果一次必须获取多个锁，则应确保其他线程不要尝试执行类似的操作。</p>
<h6 id="正确使用易失性变量"><a href="#正确使用易失性变量" class="headerlink" title="正确使用易失性变量"></a>正确使用易失性变量</h6><p>如果您已经在使用互斥锁来保护代码部分，则不要自动假定您需要使用<code>volatile</code>关键字来保护该部分中的重要变量。互斥锁包括一个内存屏障，以确保正确地排序装入和存储操作。将<code>volatile</code>关键字添加到关键部分中的变量后，每次访问该值时都会强制将其从内存中加载。两种同步技术的组合在特定情况下可能是必需的，但也会导致明显的性能损失。如果仅互斥量足以保护变量，请省略<code>volatile</code>关键字。</p>
<p>同样重要的是，不要使用易失性变量来避免使用互斥体。通常，互斥锁和其他同步机制是比易失性变量更好的方法来保护数据结构的完整性。的<code>volatile</code>关键字仅确保一个变量被从存储器加载，而不是存储在寄存器中。它不能确保您的代码正确访问该变量。</p>
<h4 id="使用原子操作"><a href="#使用原子操作" class="headerlink" title="使用原子操作"></a>使用原子操作</h4><p>非阻塞同步是一种执行某些类型的操作并避免锁定费用的方式。尽管锁是同步两个线程的有效方法，但是即使在无争议的情况下，获取锁也是相对昂贵的操作。相比之下，许多原子操作仅需花费一小部分时间即可完成，并且与锁一样有效。</p>
<p>原子运算使您可以对 32 位或 64 位值执行简单的数学和逻辑运算。这些操作依靠特殊的硬件指令（和可选的内存屏障）来确保给定的操作在再次访问受影响的内存之前完成。在多线程情况下，应始终使用包含内存屏障的原子操作来确保内存在线程之间正确同步。</p>
<p>表 4-3 列出了可用的原子数学和逻辑运算以及相应的函数名称。这些函数都在<code>/usr/include/libkern/OSAtomic.h</code>头文件中声明，您还可以在其中找到完整的语法。这些功能的 64 位版本仅在 64 位进程中可用。</p>
<table>
<thead>
<tr>
<th align="left">运作方式</th>
<th align="left">功能名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加</td>
<td align="left"><code>OSAtomicAdd32``OSAtomicAdd32Barrier``OSAtomicAdd64``OSAtomicAdd64Barrier</code></td>
<td align="left">将两个整数值相加并将结果存储在指定的变量之一中。</td>
</tr>
<tr>
<td align="left">增量</td>
<td align="left"><code>OSAtomicIncrement32``OSAtomicIncrement32Barrier``OSAtomicIncrement64``OSAtomicIncrement64Barrier</code></td>
<td align="left">将指定的整数值增加 1。</td>
</tr>
<tr>
<td align="left">减量</td>
<td align="left"><code>OSAtomicDecrement32``OSAtomicDecrement32Barrier``OSAtomicDecrement64``OSAtomicDecrement64Barrier</code></td>
<td align="left">将指定的整数值减 1。</td>
</tr>
<tr>
<td align="left">逻辑或</td>
<td align="left"><code>OSAtomicOr32``OSAtomicOr32Barrier</code></td>
<td align="left">在指定的 32 位值和 32 位掩码之间执行逻辑或。</td>
</tr>
<tr>
<td align="left">逻辑与</td>
<td align="left"><code>OSAtomicAnd32``OSAtomicAnd32Barrier</code></td>
<td align="left">在指定的 32 位值和 32 位掩码之间执行逻辑与。</td>
</tr>
<tr>
<td align="left">逻辑异或</td>
<td align="left"><code>OSAtomicXor32``OSAtomicXor32Barrier</code></td>
<td align="left">在指定的 32 位值和 32 位掩码之间执行逻辑 XOR。</td>
</tr>
<tr>
<td align="left">比较并交换</td>
<td align="left"><code>OSAtomicCompareAndSwap32``OSAtomicCompareAndSwap32Barrier``OSAtomicCompareAndSwap64``OSAtomicCompareAndSwap64Barrier``OSAtomicCompareAndSwapPtr``OSAtomicCompareAndSwapPtrBarrier``OSAtomicCompareAndSwapInt``OSAtomicCompareAndSwapIntBarrier``OSAtomicCompareAndSwapLong``OSAtomicCompareAndSwapLongBarrier</code></td>
<td align="left">将变量与指定的旧值进行比较。如果两个值相等，则此函数将指定的新值分配给变量；否则，它什么都不做。比较和赋值作为一个原子操作完成，并且该函数返回一个布尔值，该布尔值指示是否实际发生了交换。</td>
</tr>
<tr>
<td align="left">测试并设定</td>
<td align="left"><code>OSAtomicTestAndSet``OSAtomicTestAndSetBarrier</code></td>
<td align="left">测试指定变量中的某个位，将该位设置为 1，然后将旧位的值作为布尔值返回。根据<code>(0x80 &gt;&gt; (n &amp; 7))</code>字节的公式测试位，<code>((char*)address + (n &gt;&gt; 3))</code>其中<code>n</code>是位号，<code>address</code>是指向变量的指针。该公式有效地将变量分解为 8 位大小的块，并按相反的顺序对每个块中的位进行排序。例如，要测试 32 位整数的最低位（位 0），您实际上应将位数指定为 7；同样，要测试最高阶位（位 32），请为位号指定 24。</td>
</tr>
<tr>
<td align="left">测试并清除</td>
<td align="left"><code>OSAtomicTestAndClear``OSAtomicTestAndClearBarrier</code></td>
<td align="left">测试指定变量中的某个位，将该位设置为 0，然后将旧位的值作为布尔值返回。根据<code>(0x80 &gt;&gt; (n &amp; 7))</code>字节的公式测试位，<code>((char*)address + (n &gt;&gt; 3))</code>其中<code>n</code>是位号，<code>address</code>是指向变量的指针。该公式有效地将变量分解为 8 位大小的块，并按相反的顺序对每个块中的位进行排序。例如，要测试 32 位整数的最低位（位 0），您实际上应将位数指定为 7；同样，要测试最高阶位（位 32），请为位号指定 24。</td>
</tr>
</tbody></table>
<p>大多数原子函数的行为应相对简单明了，并具有您所期望的。但是，清单 4-1 显示了原子测试设置和比较交换操作的行为，这些操作稍微复杂一些。对<code>OSAtomicTestAndSet</code>函数的前三个调用说明了对整数值使用的位操作公式及其结果可能与您期望的不同。最后两个调用显示了该<code>OSAtomicCompareAndSwap32</code>函数的行为。在所有情况下，当没有其他线程在操纵这些值时，将在无争议的情况下调用这些函数。</p>
<p><strong>清单 4-1</strong> 执行原子操作</p>
<table>
<thead>
<tr>
<th><code>int32_t theValue = 0;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>OSAtomicTestAndSet（0，＆theValue）;</code></td>
</tr>
<tr>
<td><code>// theValue现在为128。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>theValue = 0;</code></td>
</tr>
<tr>
<td><code>OSAtomicTestAndSet（7，＆theValue）;</code></td>
</tr>
<tr>
<td><code>// theValue现在为1。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>theValue = 0;</code></td>
</tr>
<tr>
<td><code>OSAtomicTestAndSet（15，＆theValue）</code></td>
</tr>
<tr>
<td><code>// theValue现在为256。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>OSAtomicCompareAndSwap32（256，512，＆theValue）;</code></td>
</tr>
<tr>
<td><code>// theValue现在为512。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>OSAtomicCompareAndSwap32（256，1024，＆theValue）;</code></td>
</tr>
<tr>
<td><code>// theValue仍然是512。</code></td>
</tr>
</tbody></table>
<p>有关原子操作的信息，请参见<code>atomic</code>手册页和<code>/usr/include/libkern/OSAtomic.h</code>头文件。</p>
<h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><p>锁是用于线程编程的基本同步工具。锁使您可以轻松保护大部分代码，从而可以确保该代码的正确性。OS X 和 iOS 为所有应用程序类型提供基本互斥锁，并且 Foundation 框架为特殊情况定义了互斥锁的一些其他变体。以下各节说明如何使用这些锁类型中的几种。</p>
<h6 id="使用-POSIX-互斥锁"><a href="#使用-POSIX-互斥锁" class="headerlink" title="使用 POSIX 互斥锁"></a>使用 POSIX 互斥锁</h6><p>POSIX 互斥锁在任何应用程序中都非常易于使用。要创建互斥锁，您需要声明并初始化一个<code>pthread_mutex_t</code>结构。要锁定和解锁互斥锁，请使用<code>pthread_mutex_lock</code> 和 <code>pthread_mutex_unlock</code>功能。清单 4-2 显示了初始化和使用 POSIX 线程互斥锁所需的基本代码。完成锁后，只需致电<code>pthread_mutex_destroy</code> 释放锁数据结构。</p>
<p><strong>清单 4-2</strong> 使用互斥锁</p>
<table>
<thead>
<tr>
<th><code>pthread_mutex_t互斥体;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>void MyInitFunction（）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>pthread_mutex_init（＆mutex，NULL）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>void MyLockingFunction（）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>pthread_mutex_lock（＆mutex）;</code></td>
</tr>
<tr>
<td><code>// 做工作。</code></td>
</tr>
<tr>
<td><code>pthread_mutex_unlock（＆mutex）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 前面的代码是一个简化的示例，旨在显示 POSIX 线程互斥函数的基本用法。您自己的代码应检查这些函数返回的错误代码并进行适当处理。</p>
<h6 id="使用-NSLock-类"><a href="#使用-NSLock-类" class="headerlink" title="使用 NSLock 类"></a>使用 NSLock 类</h6><p>一个 <code>NSLock</code>对象为 Cocoa 应用程序实现基本互斥量。所有锁（包括<code>NSLock</code>）的接口实际上都是由<code>NSLocking</code>协议定义的，协议定义了<code>lock</code>和<code>unlock</code>方法。您可以像使用任何互斥锁一样使用这些方法来获取和释放锁。</p>
<p>除了标准的锁定行为外，<code>NSLock</code>该类还添加了<code>tryLock</code> 和 <code>lockBeforeDate:</code>方法。该<code>tryLock</code>方法尝试获取锁，但是如果锁不可用则不会阻塞；相反，该方法仅返回<code>NO</code>。如果未在指定的时间限制内获取锁，则该<code>lockBeforeDate:</code>方法尝试获取锁，但取消阻塞线程（并返回<code>NO</code>）。</p>
<p>下面的示例演示如何使用<code>NSLock</code>对象来协调视觉显示的更新，该视觉显示的数据是由多个线程计算的。如果线程无法立即获取锁，则仅继续执行计算，直到可以获取锁并更新显示。</p>
<table>
<thead>
<tr>
<th><code>BOOL moreToDo = YES;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>NSLock * theLock = [[NSLock alloc] init];</code></td>
</tr>
<tr>
<td><code>...</code></td>
</tr>
<tr>
<td><code>而（moreToDo）&#123;</code></td>
</tr>
<tr>
<td><code>/ *再进行一次计算* /</code></td>
</tr>
<tr>
<td><code>/ *，直到没有其他事情可做为止。* /</code></td>
</tr>
<tr>
<td><code>如果（[theLock tryLock]）&#123;</code></td>
</tr>
<tr>
<td><code>/ *更新所有线程使用的显示。* /</code></td>
</tr>
<tr>
<td><code>[theLock解锁]；</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<h6 id="使用-synchronized-指令"><a href="#使用-synchronized-指令" class="headerlink" title="使用@synchronized 指令"></a>使用@synchronized 指令</h6><p>该<code>@synchronized</code>指令是在 Objective-C 代码中动态创建互斥锁的便捷方法。该<code>@synchronized</code>指令执行任何其他互斥锁将执行的操作-防止不同的线程同时获取同一锁。但是，在这种情况下，您不必直接创建互斥量或锁定对象。相反，您只需将任何 Objective-C 对象用作锁定令牌，如以下示例所示：</p>
<table>
<thead>
<tr>
<th><code>-（void）myMethod：（id）anObj</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>@synchronized（anObj）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//大括号之间的所有内容均受@synchronized指令保护。</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>传递给<code>@synchronized</code>指令的对象是用于区分受保护块的唯一标识符。如果在两个不同的线程中执行上述方法，并<code>anObj</code>在每个线程上为参数传递一个不同的对象，则每个线程将获得其锁并继续进行处理而不会被另一个线程阻塞。但是，如果在两种情况下都传递相同的对象，则其中一个线程将首先获取锁，而另一个线程将阻塞，直到第一个线程完成关键部分。</p>
<p>作为一种预防措施，该<code>@synchronized</code>块会向受保护的代码隐式添加一个异常处理程序。如果抛出异常，此处理程序将自动释放互斥量。这意味着，为了使用该<code>@synchronized</code>指令，还必须在代码中启用 Objective-C 异常处理。如果您不希望由隐式异常处理程序引起的额外开销，则应考虑使用锁类。</p>
<p>有关<code>@synchronized</code>指令的更多信息，请参见*<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163">Objective-C 编程语言</a>*。</p>
<h6 id="使用其他可可锁"><a href="#使用其他可可锁" class="headerlink" title="使用其他可可锁"></a>使用其他可可锁</h6><p>以下各节描述了使用其他几种类型的可可锁的过程。</p>
<p>######## 使用 NSRecursiveLock 对象</p>
<p>该<code>NSRecursiveLock</code>班定义一个锁，同一线程可以多次获取该锁，而不会导致线程死锁。递归锁跟踪成功获取了多少次。每次成功获取锁，必须通过相应的调用来平衡以解锁该锁。仅当所有锁定和解锁调用均达到平衡时，才实际释放该锁定，以便其他线程可以获取它。</p>
<p>顾名思义，这种类型的锁通常在递归函数内部使用，以防止递归阻塞线程。在非递归情况下，您可以类似地使用它来调用函数，这些函数的语义要求它们也具有锁定功能。这是一个简单的递归函数示例，该函数通过递归获取锁。如果您没有<code>NSRecursiveLock</code>为此代码使用对象，则当再次调用该函数时，线程将死锁。</p>
<table>
<thead>
<tr>
<th><code>NSRecursiveLock * theLock = [[NSRecursiveLock alloc] init];</code></th>
</tr>
</thead>
<tbody><tr>
<td>``</td>
</tr>
<tr>
<td><code>void MyRecursiveFunction（int value）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>[theLock锁];</code></td>
</tr>
<tr>
<td><code>如果（值！= 0）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>- 值;</code></td>
</tr>
<tr>
<td><code>MyRecursiveFunction（value）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td><code>[theLock解锁]；</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>MyRecursiveFunction（5）;</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 由于在所有锁调用与解锁调用平衡之前不会释放递归锁，因此您应仔细权衡使用性能锁的决定与潜在的性能影响。长时间持有任何锁都可能导致其他线程阻塞，直到递归完成为止。如果您可以重写代码以消除递归或不需要使用递归锁，则可能会获得更好的性能。</p>
<p>######## 使用 NSConditionLock 对象</p>
<p>一个<code>NSConditionLock</code>对象定义了一个互斥锁，该互斥锁可以使用特定的值进行锁定和解锁。您不应将这种类型的锁与条件混淆（请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-126424">条件</a>）。该行为在某种程度上类似于条件，但实现方式却大不相同。</p>
<p>通常，<code>NSConditionLock</code>当线程需要按特定顺序执行任务时（例如，当一个线程产生另一个线程消耗的数据时），您可以使用一个对象。生产者执行时，消费者使用特定于您的程序的条件来获取锁。（条件本身只是您定义的整数值。）生产者完成时，它将解锁锁，并将锁定条件设置为适当的整数值以唤醒使用者线程，然后消费者线程继续处理数据。</p>
<p><code>NSConditionLock</code>对象响应的锁定和解锁方法可以任意组合使用。例如，您可以将一条<code>lock</code>消息与<code>unlockWithCondition:</code>或 <code>lockWhenCondition:</code>的消息<code>unlock</code>。当然，后一种组合可以解锁该锁，但可能不会释放等待特定条件值的任何线程。</p>
<p>下面的示例显示如何使用条件锁来处理生产者－消费者问题。想象一个应用程序包含一个数据队列。生产者线程将数据添加到队列，而消费者线程从队列中提取数据。生产者不必等待特定的条件，但是必须等待锁可用，以便可以安全地将数据添加到队列中。</p>
<table>
<thead>
<tr>
<th><code>id condLock = [[NSConditionLock alloc] initWithCondition：NO_DATA];</code></th>
</tr>
</thead>
<tbody><tr>
<td>``</td>
</tr>
<tr>
<td><code>而（真）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>[condLock锁定]；</code></td>
</tr>
<tr>
<td><code>/ *将数据添加到队列。* /</code></td>
</tr>
<tr>
<td><code>[condLock unlockWithCondition：HAS_DATA];</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>因为锁的初始条件设置为<code>NO_DATA</code>，所以生产者线程应该在最初获取锁时没有任何麻烦。它用数据填充队列，并将条件设置为<code>HAS_DATA</code>。在后续迭代期间，生产者线程可以在到达时添加新数据，而不管队列是空还是仍有一些数据。它唯一阻止的时间是使用者线程从队列中提取数据。</p>
<p>因为使用者线程必须要处理数据，所以它使用特定条件在队列上等待。当生产者将数据放入队列时，消费者线程将唤醒并获取其锁。然后，它可以从队列中提取一些数据并更新队列状态。以下示例显示了使用者线程处理循环的基本结构。</p>
<table>
<thead>
<tr>
<th><code>而（真）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>[condLock lockWhenCondition：HAS_DATA];</code></td>
</tr>
<tr>
<td><code>/ *从队列中删除数据。* /</code></td>
</tr>
<tr>
<td><code>[condLock unlockWithCondition：（isEmpty？NO_DATA：HAS_DATA）]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//在本地处理数据。</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>######## 使用 NSDistributedLock 对象</p>
<p>该<code>NSDistributedLock</code>班 可以被多个主机上的多个应用程序用来限制对某些共享资源（例如文件）的访问。该锁本身实际上是使用文件系统项（如文件或目录）实现的互斥锁。为了使<code>NSDistributedLock</code>对象可用，该锁必须可由使用它的所有应用程序写入。这通常意味着将其放置在运行该应用程序的所有计算机都可以访问的文件系统上。</p>
<p>与其他类型的锁不同，<code>NSDistributedLock</code>它不符合<code>NSLocking</code>协议，因此没有<code>lock</code>方法。一种<code>lock</code>方法将阻止线程的执行，并要求系统以预定速率轮询锁。与其对您的代码强加惩罚，不如<code>NSDistributedLock</code>提供<code>tryLock</code> 方法，让您决定是否要轮询。</p>
<p>因为它是使用文件系统实现的，所以<code>NSDistributedLock</code>除非所有者明确释放对象，否则不会释放对象。如果您的应用程序在持有分布式锁的同时崩溃，则其他客户端将无法访问受保护的资源。在这种情况下，您可以使用<code>breakLock</code>打破现有锁的方法，以便您可以获取它。但是，通常应该避免破坏锁，除非您确定拥有进程已死并且无法释放锁。</p>
<p>与其他类型的锁一样，使用<code>NSDistributedLock</code>完对象后，可以通过调用<code>unlock</code>方法来释放它。</p>
<h4 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h4><p>条件是一种特殊类型的锁，可用于同步操作必须执行的顺序。它们与互斥锁有一个微妙的区别。等待某个条件的线程保持阻塞状态，直到该条件被另一个线程显式发出信号为止。</p>
<p>由于实现操作系统所涉及的微妙之处，即使代码未真正发出条件锁，也允许伪造成功返回条件锁。为了避免由这些虚假信号引起的问题，您应始终将谓词与条件锁结合使用。谓词是确定线程继续执行是否安全的更具体方法。该条件只是让您的线程处于睡眠状态，直到可以由信令线程设置谓词为止。</p>
<p>以下各节说明如何在代码中使用条件。</p>
<h6 id="使用-NSCondition-类"><a href="#使用-NSCondition-类" class="headerlink" title="使用 NSCondition 类"></a>使用 NSCondition 类</h6><p>的<code>NSCondition</code>类提供相同的语义 POSIX 的条件，但在单个对象包装二者所需的锁和条件数据结构。结果是可以像互斥锁一样锁定对象，然后像条件一样等待。</p>
<p>清单 4-3 显示了一个代码片段，演示了等待<code>NSCondition</code>对象的事件序列。该<code>cocoaCondition</code>变量包含一个<code>NSCondition</code>对象，并且该<code>timeToDoWork</code>变量是一个整数，在发出该信号之前立即从另一个线程递增。</p>
<p><strong>清单 4-3</strong> 使用可可条件</p>
<table>
<thead>
<tr>
<th><code>[cocoaCondition锁];</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>一会儿（timeToDoWork &lt;= 0）</code></td>
</tr>
<tr>
<td><code>[cocoaCondition等待]；</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>timeToDoWork--;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//在这里做真实的工作。</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>[cocoaCondition解锁]；</code></td>
</tr>
</tbody></table>
<p>清单 4-4 显示了用于发出可可条件信号并增加谓词变量的代码。您应该始终在发出信号之前锁定该条件。</p>
<p><strong>清单 4-4</strong> 发出可可状况信号</p>
<table>
<thead>
<tr>
<th><code>[cocoaCondition锁];</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>timeToDoWork ++;</code></td>
</tr>
<tr>
<td><code>[可可状态信号]；</code></td>
</tr>
<tr>
<td><code>[cocoaCondition解锁]；</code></td>
</tr>
</tbody></table>
<h6 id="使用-POSIX-条件"><a href="#使用-POSIX-条件" class="headerlink" title="使用 POSIX 条件"></a>使用 POSIX 条件</h6><p>POSIX 线程条件锁需要同时使用条件数据结构和互斥量。尽管两个锁结构是分开的，但互斥锁在运行时与条件结构密切相关。等待信号的线程应始终一起使用相同的互斥锁和条件结构。更改配对会导致错误。</p>
<p>清单 4-5 显示了条件和谓词的基本初始化和用法。在初始化条件和互斥锁之后，等待线程使用该<code>ready_to_go</code>变量作为其谓词进入 while 循环。仅当谓词已设置且随后发出条件通知时，等待线程才会唤醒并开始执行其工作。</p>
<p><strong>清单 4-5</strong> 使用 POSIX 条件</p>
<table>
<thead>
<tr>
<th><code>pthread_mutex_t互斥体;</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>pthread_cond_t条件;</code></td>
</tr>
<tr>
<td><code>布尔值ready_to_go = true;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>void MyCondInitFunction（）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>pthread_mutex_init（＆mutex）;</code></td>
</tr>
<tr>
<td><code>pthread_cond_init（＆condition，NULL）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>void MyWaitOnConditionFunction（）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//锁定互斥锁。</code></td>
</tr>
<tr>
<td><code>pthread_mutex_lock（＆mutex）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//如果谓词已经设置，则while循环被绕过；</code></td>
</tr>
<tr>
<td><code>//否则，线程将休眠直到谓词被设置。</code></td>
</tr>
<tr>
<td><code>while（ready_to_go == false）</code></td>
</tr>
<tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>pthread_cond_wait（＆condition，＆mutex）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>// 做工作。（互斥锁应保持锁定状态。）</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//重置谓词并释放互斥量。</code></td>
</tr>
<tr>
<td><code>ready_to_go = false;</code></td>
</tr>
<tr>
<td><code>pthread_mutex_unlock（＆mutex）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p>信令线程既负责设置谓词，也负责将信号发送到条件锁。 清单 4-6 显示了实现此行为的代码。在此示例中，条件在互斥锁内部发出信号，以防止在等待条件的线程之间发生竞争条件。</p>
<p><strong>清单 4-6 发</strong> 信号通知条件锁定</p>
<table>
<thead>
<tr>
<th><code>void SignalThreadUsingCondition（）</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;</code></td>
</tr>
<tr>
<td><code>//此时，应该有另一个线程要做的工作。</code></td>
</tr>
<tr>
<td><code>pthread_mutex_lock（＆mutex）;</code></td>
</tr>
<tr>
<td><code>ready_to_go = true;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>//通知另一个线程开始工作。</code></td>
</tr>
<tr>
<td><code>pthread_cond_signal（＆condition）;</code></td>
</tr>
<tr>
<td>``</td>
</tr>
<tr>
<td><code>pthread_mutex_unlock（＆mutex）;</code></td>
</tr>
<tr>
<td><code>&#125;</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 前面的代码是一个简化的示例，旨在显示 POSIX 线程条件函数的基本用法。您自己的代码应检查这些函数返回的错误代码并进行适当处理。</p>
<h2 id="线程安全摘要"><a href="#线程安全摘要" class="headerlink" title="线程安全摘要"></a>线程安全摘要</h2><p>本附录描述了 OS X 和 iOS 中某些关键框架的高级线程安全性。本附录中的信息可能会更改。</p>
<h4 id="可可"><a href="#可可" class="headerlink" title="可可"></a>可可</h4><p>从多个线程使用可可的准则包括：</p>
<ul>
<li>不可变对象通常是线程安全的。创建它们之后，就可以安全地在线程之间传递这些对象。另一方面，可变对象通常不是线程安全的。要在线程应用程序中使用可变对象，应用程序必须适当地同步。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/20000736-126010">可变与不可变</a>。</li>
<li>许多被认为“线程不安全”的对象仅在多个线程中使用是不安全的。只要一次仅一个线程，就可以从任何线程使用许多这些对象。专门调出应用程序主线程的对象就这样被调出。</li>
<li>应用程序的主线程负责处理事件。尽管如果事件路径中包含其他线程，Application Kit 仍可以继续工作，但是操作可能会不按顺序进行。</li>
<li>如果要使用线程绘制视图，请在的<code>lockFocusIfCanDraw</code>和<code>unlockFocus</code>方法之间将所有绘制代码括在括号中<code>NSView</code>。</li>
<li>要将 POSIX 线程与 Cocoa 一起使用，必须首先将 Cocoa 置于多线程模式。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/20000738-125024">在 Cocoa 应用程序中使用 POSIX 线程</a>。</li>
</ul>
<h6 id="基础框架线程安全"><a href="#基础框架线程安全" class="headerlink" title="基础框架线程安全"></a>基础框架线程安全</h6><p>有一个误解，认为 Foundation 框架是线程安全的，而 Application Kit 框架不是。不幸的是，这是一个粗略的概括并且有些误导。每个框架都有线程安全的区域和不是线程安全的区域。以下各节描述了 Foundation 框架的一般线程安全性。</p>
<p>######## 线程安全的类和函数</p>
<p>以下类和函数通常被认为是线程安全的。您可以从多个线程使用同一实例，而无需先获取锁。</p>
<ul>
<li><code>NSArray</code></li>
<li><code>NSAssertionHandler</code></li>
<li><code>NSAttributedString</code></li>
<li><code>NSBundle</code></li>
<li><code>NSCalendar</code></li>
<li><code>NSCalendarDate</code></li>
<li><code>NSCharacterSet</code></li>
<li><code>NSConditionLock</code></li>
<li><code>NSConnection</code></li>
<li><code>NSData</code></li>
<li><code>NSDate</code></li>
<li><code>NSDateFormatter</code></li>
<li><code>NSDecimal</code> 功能</li>
<li><code>NSDecimalNumber</code></li>
<li><code>NSDecimalNumberHandler</code></li>
<li><code>NSDeserializer</code></li>
<li><code>NSDictionary</code></li>
<li><code>NSDistantObject</code></li>
<li><code>NSDistributedLock</code></li>
<li><code>NSDistributedNotificationCenter</code></li>
<li><code>NSException</code></li>
<li><code>NSFileManager</code></li>
<li><code>NSFormatter</code></li>
<li><code>NSHost</code></li>
<li><code>NSJSONSerialization</code></li>
<li><code>NSLock</code></li>
<li><code>NSLog</code>/<code>NSLogv</code></li>
<li><code>NSMethodSignature</code></li>
<li><code>NSNotification</code></li>
<li><code>NSNotificationCenter</code></li>
<li><code>NSNumber</code></li>
<li><code>NSNumberFormatter</code></li>
<li><code>NSObject</code></li>
<li><code>NSOrderedSet</code></li>
<li><code>NSPortCoder</code></li>
<li><code>NSPortMessage</code></li>
<li><code>NSPortNameServer</code></li>
<li><code>NSProgress</code></li>
<li><code>NSProtocolChecker</code></li>
<li><code>NSProxy</code></li>
<li><code>NSRecursiveLock</code></li>
<li><code>NSSet</code></li>
<li><code>NSString</code></li>
<li><code>NSThread</code></li>
<li><code>NSTimer</code></li>
<li><code>NSTimeZone</code></li>
<li><code>NSUserDefaults</code></li>
<li><code>NSValue</code></li>
<li><code>NSXMLParser</code></li>
<li>对象分配和保留计数功能</li>
<li>区域和记忆功能</li>
</ul>
<p>######## 线程不安全类</p>
<p>以下类和函数通常不是线程安全的。在大多数情况下，您可以从任何线程使用这些类，只要一次仅从一个线程使用它们即可。检查类文档以获取更多详细信息。</p>
<ul>
<li><code>NSArchiver</code></li>
<li><code>NSAutoreleasePool</code></li>
<li><code>NSCoder</code></li>
<li><code>NSCountedSet</code></li>
<li><code>NSEnumerator</code></li>
<li><code>NSFileHandle</code></li>
<li><code>NSHashTable</code> 功能</li>
<li><code>NSInvocation</code></li>
<li><code>NSMapTable</code> 功能</li>
<li><code>NSMutableArray</code></li>
<li><code>NSMutableAttributedString</code></li>
<li><code>NSMutableCharacterSet</code></li>
<li><code>NSMutableData</code></li>
<li><code>NSMutableDictionary</code></li>
<li><code>NSMutableOrderedSet</code></li>
<li><code>NSMutableSet</code></li>
<li><code>NSMutableString</code></li>
<li><code>NSNotificationQueue</code></li>
<li><code>NSPipe</code></li>
<li><code>NSPort</code></li>
<li><code>NSProcessInfo</code></li>
<li><code>NSRunLoop</code></li>
<li><code>NSScanner</code></li>
<li><code>NSSerializer</code></li>
<li><code>NSTask</code></li>
<li><code>NSUnarchiver</code></li>
<li><code>NSUndoManager</code></li>
<li>用户名和主目录功能</li>
</ul>
<p>请注意，尽管<code>NSArchiver</code>，<code>NSCoder</code>和<code>NSEnumerator</code>对象本身都是线程安全的，但在此处列出它们是因为在使用它们时更改由它们包装的数据对象并不安全。例如，对于归档器，更改要归档的对象图是不安全的。对于枚举，任何线程更改枚举集合都是不安全的。</p>
<p>######## 仅主线程类</p>
<p>只能在应用程序的主线程中使用以下类。</p>
<ul>
<li><code>NSAppleScript</code></li>
</ul>
<p>######## 可变与不可变</p>
<p>不变的对象通常是线程安全的；创建它们之后，就可以安全地在线程之间传递这些对象。当然，当使用不可变对象时，您仍然需要记住正确使用引用计数。如果不当释放了一个未保留的对象，则稍后可能会导致异常。</p>
<p>可变对象通常不是线程安全的。要在线程应用程序中使用可变对象，应用程序必须使用锁同步对它们的访问。（有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW2">原子操作</a>）。通常，当涉及到突变时，收集类（例如<code>NSMutableArray</code>，<code>NSMutableDictionary</code>）不是线程安全的。也就是说，如果一个或多个线程正在更改同一阵列，则可能会出现问题。您必须锁定发生读写的地方，以确保线程安全。</p>
<p>即使某个方法声称要返回一个不可变的对象，您也绝不能简单地假设返回的对象是不可变的。根据方法的实现，返回的对象可能是可变的或不可变的。例如，返回类型为的方法<code>NSString</code>可能会<code>NSMutableString</code>由于其实现而实际上返回 a 。如果要保证所拥有的对象是不可变的，则应制作不可变的副本。</p>
<p>######## 再入</p>
<p>只有在操作“调出”同一对象或不同对象上的其他操作的情况下，才可以重入。保留和释放物体是一种有时被忽略的“召唤”。</p>
<p>下表列出了 Foundation 框架中明确可重入的部分。所有其他类别可能会也可能不会重入，或者将来可能会重入。尚未对折返进行完整的分析，此列表可能并不详尽。</p>
<ul>
<li>分布式对象</li>
<li><code>NSConditionLock</code></li>
<li><code>NSDistributedLock</code></li>
<li><code>NSLock</code></li>
<li><code>NSLog</code>/<code>NSLogv</code></li>
<li><code>NSNotificationCenter</code></li>
<li><code>NSRecursiveLock</code></li>
<li><code>NSRunLoop</code></li>
<li><code>NSUserDefaults</code></li>
</ul>
<p>######## 类初始化</p>
<p>Objective-C 运行时系统发送一个 <code>initialize</code>在类收到任何其他消息之前，向每个类对象发送消息。这使该类有机会设置其运行时环境在使用之前。在多线程应用程序中，运行时保证只有一个线程（恰好将第一条消息发送给类的线程）执行该<code>initialize</code>方法。如果在第一个线程仍在该<code>initialize</code>方法中时第二个线程尝试向该类发送消息，则第二个线程将阻塞直到该<code>initialize</code>方法完成执行。同时，第一个线程可以继续调用该类上的其他方法。该<code>initialize</code>方法不应依赖于该类的第二个线程调用方法。如果是这样，则两个线程将陷入僵局。</p>
<p>由于 OS X 版本 10.1.x 和更早版本中的错误，一个线程可以在另一个线程完成执行该类的<code>initialize</code>方法之前将消息发送给该类。然后，线程可以访问尚未完全初始化的值，这可能会使应用程序崩溃。如果遇到此问题，则需要引入锁以防止在初始化值之前访问值，或者强制类在成为多线程之前对其进行初始化。</p>
<p>######## 自动释放池</p>
<p>每个线程维护自己的<code>NSAutoreleasePool</code>对象堆栈。Cocoa 希望在当前线程的堆栈上始终有一个自动释放池。如果池不可用，则不会释放对象，并且会泄漏内存。一个<code>NSAutoreleasePool</code>对象会自动创建并在基于应用程序套件应用的主线程摧毁，但辅助线程（和基金会只应用）必须在使用前，可可创建自己的。如果您的线程是长期存在的，并可能生成许多自动释放的对象，您应该定期销毁并创建自动释放池（就像 Application Kit 在主线程上一样）；否则，自动释放的对象会堆积，并且您的内存占用也会增加。如果分离的线程不使用 Cocoa，则无需创建自动释放池。</p>
<p>######## 运行循环</p>
<p>每个线程只有一个运行循环。但是，每个运行循环以及每个线程都有自己的一组输入模式，这些输入模式确定运行运行循环时侦听哪些输入源。一个运行循环中定义的输入模式不会影响另一个运行循环中定义的输入模式，即使它们的名称相同。</p>
<p>如果您的应用程序基于 Application Kit，则主线程的运行循环将自动运行，但是辅助线程（和仅基金会的应用程序）必须自己运行运行循环。如果分离的线程未进入运行循环，则该线程将在分离的方法完成执行后立即退出。</p>
<p>尽管有一些外表，但<code>NSRunLoop</code>该类不是线程安全的。您只能从拥有它的线程中调用此类的实例方法。</p>
<h6 id="应用套件框架线程安全"><a href="#应用套件框架线程安全" class="headerlink" title="应用套件框架线程安全"></a>应用套件框架线程安全</h6><p>以下各节描述了 Application Kit 框架的一般线程安全性。</p>
<p>######## 线程不安全类</p>
<p>以下类和函数通常不是线程安全的。在大多数情况下，您可以从任何线程使用这些类，只要一次仅从一个线程使用它们即可。检查类文档以获取更多详细信息。</p>
<ul>
<li><code>NSGraphicsContext</code>。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-126712">NSGraphicsContext 限制</a>。</li>
<li><code>NSImage</code>。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-126728">NSImage 限制</a>。</li>
<li><code>NSResponder</code></li>
<li><code>NSWindow</code>及其所有后代。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-123364">窗口限制</a>。</li>
</ul>
<p>######## 仅主线程类</p>
<p>只能在应用程序的主线程中使用以下类。</p>
<ul>
<li><code>NSCell</code> 及其所有后代</li>
<li><code>NSView</code>及其所有后代。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-123427">NSView 限制</a>。</li>
</ul>
<p>######## 窗口限制</p>
<p>您可以在辅助线程上创建一个窗口。应用程序包确保与窗口关联的数据结构在主线程上被重新分配，以避免出现竞争情况。窗口对象可能会在同时处理大量窗口的应用程序中泄漏。</p>
<p>您可以在辅助线程上创建模式窗口。当主线程运行模式循环时，应用程序工具包将阻止正在调用的辅助线程。</p>
<p>######## 事件处理限制</p>
<p>应用程序的主线程负责处理事件。主线程是的<code>run</code>方法中被阻塞的线程<code>NSApplication</code>，通常在应用程序的<code>main</code>函数中调用。如果事件路径中涉及其他线程，则 Application Kit 继续工作时，操作可能会不按顺序进行。例如，如果两个不同的线程正在响应按键事件，则可能会乱序接收按键。通过让主线程处理事件，您可以获得更一致的用户体验。接收到事件后，如果需要，可以将事件调度到辅助线程进行进一步处理。</p>
<p>您可以从辅助线程调用<code>postEvent:atStart:</code>方法，<code>NSApplication</code>以将事件发布到主线程的事件队列中。但是，不能保证有关用户输入事件的顺序。应用程序的主线程仍负责处理事件队列中的事件。</p>
<p>######## 绘图限制</p>
<p>使用其图形功能和类（包括<code>NSBezierPath</code>和<code>NSString</code>类）进行绘制时，Application Kit 通常是线程安全的。以下各节介绍了使用特定类的详细信息。有关绘图和螺纹的更多信息，请参见《_<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290">可可绘图指南》</a>_。</p>
<p>########## NSView 限制</p>
<p>该<code>NSView</code>班通常不是线程安全的。您<code>NSView</code>仅应从应用程序的主线程创建，销毁，调整大小，移动对象并执行其他操作。从辅助线程进行绘图是线程安全的，只要将绘图调用与<code>lockFocusIfCanDraw</code> 和 <code>unlockFocus</code>。</p>
<p>如果一个应用程序的一个次级线程想要使视图的部分是主要的线程上重新绘制，它必须这样做使用的方法，如<code>display</code>，<code>setNeedsDisplay:</code>，<code>setNeedsDisplayInRect:</code>，或<code>setViewsNeedDisplay:</code>。相反，它应该向主线程发送一条消息，或使用<code>performSelectorOnMainThread:withObject:waitUntilDone:</code> 方法代替。</p>
<p>视图系统的图形状态（gstates）是每个线程的。使用图形状态曾经是在单线程应用程序上获得更好绘图性能的一种方式，但是现在不再如此。错误使用图形状态实际上会导致绘制代码的效率低于在主线程中绘制的效率。</p>
<p>########## NSGraphicsContext 限制</p>
<p>该<code>NSGraphicsContext</code>班表示基础图形系统提供的绘图上下文。每个<code>NSGraphicsContext</code>实例都拥有自己独立的图形状态：坐标系，剪辑，当前字体等。在每个<code>NSWindow</code>实例的主线程上自动创建该类的实例。如果您从辅助线程进行任何绘图，<code>NSGraphicsContext</code>则会专门为该线程创建一个新的实例。</p>
<p>如果从辅助线程进行任何绘图，则必须手动刷新绘图调用。Cocoa 不会自动使用从辅助线程绘制的内容来更新视图，因此您需要在完成绘制时调用<code>flushGraphics</code>方法<code>NSGraphicsContext</code>。如果您的应用程序仅从主线程绘制内容，则无需刷新绘制调用。</p>
<p>########## NSImage 限制</p>
<p>一个线程可以创建一个<code>NSImage</code>对象，绘制到图像缓冲区，然后将其传递给主线程进行绘制。基础图像缓存在所有线程之间共享。有关图像以及缓存如何工作的更多信息，请参见*<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290">Cocoa Drawing Guide</a>*。</p>
<h6 id="核心数据框架"><a href="#核心数据框架" class="headerlink" title="核心数据框架"></a>核心数据框架</h6><p>尽管有一些使用注意事项，但 Core Data 框架通常支持线程化。有关这些警告信息，请参阅并发与核心数据的*<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075">核心数据编程指南</a>*。</p>
<h4 id="核心基础"><a href="#核心基础" class="headerlink" title="核心基础"></a>核心基础</h4><p>Core Foundation 具有足够的线程安全性，因此，如果谨慎编程，就不会遇到与竞争线程有关的任何问题。在常见情况下，例如查询，保留，释放和传递不可变对象时，它是线程安全的。即使是可能从多个线程中查询的中央共享对象，也是可靠的线程安全的。</p>
<p>像 Cocoa 一样，当涉及对象或其内容的突变时，Core Foundation 也不是线程安全的。例如，正如您可能期望的那样，修改可变数据或可变数组对象不是线程安全的，但修改不可变数组内部的对象也不是线程安全的。原因之一就是性能，这在这些情况下至关重要。此外，通常无法在此级别上实现绝对线程安全。例如，您不能排除由于保留从集合中获取的对象而导致的不确定行为。在进行调用以保留包含的对象之前，可能会释放集合本身。</p>
<p>在要从多个线程访问和变异的 Core Foundation 对象的情况下，您的代码应通过在访问点使用锁来防止同时访问。例如，枚举 Core Foundation 数组对象的代码应在枚举块周围使用适当的锁定调用，以防止其他人更改该数组。</p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><ul>
<li><p>应用</p>
<p>一种特定的<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Glossary/Glossary.html#//apple_ref/doc/uid/10000057i-CH13-SW3">程序</a>样式，向用户显示图形界面。</p>
</li>
<li><p>健康）状况</p>
<p>用于同步对资源的访问的构造。在其他条件明确指示条件之前，不允许等待条件的线程继续进行。</p>
</li>
<li><p>关键部分</p>
<p>一次只能由一个线程执行的一部分代码。</p>
</li>
<li><p>输入源</p>
<p>线程的异步事件的源。输入源可以基于端口或手动触发，并且必须附加到线程的运行循环中。</p>
</li>
<li><p>可连接线程</p>
<p>终止后不会立即回收其资源的线程。必须先显式地分离可连接线程，否则必须由另一个线程将其连接，才能回收资源。可连接线程为与它们连接的线程提供返回值。</p>
</li>
<li><p>主线</p>
<p>创建其拥有进程时创建的一种特殊类型的<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Glossary/Glossary.html#//apple_ref/doc/uid/10000057i-CH13-SW1">线程</a>。当程序的主线程退出时，该过程结束。</p>
</li>
<li><p>互斥体</p>
<p>提供互斥访问共享资源的锁。互斥锁一次只能由一个线程持有。尝试获取由其他线程持有的互斥锁会使当前线程进入休眠状态，直到最终获取该锁为止。</p>
</li>
<li><p>操作对象</p>
<p><code>NSOperation</code>类的实例。操作对象将与任务关联的代码和数据包装到可执行单元中。</p>
</li>
<li><p>操作队列</p>
<p><code>NSOperationQueue</code>类的实例。操作队列管理操作对象的执行。</p>
</li>
<li><p>处理</p>
<p>应用程序或程序的运行时实例。进程具有自己的虚拟内存空间和系统资源（包括端口权限），与分配给其他程序的资源无关。一个进程始终至少包含一个线程（主线程），并且可以包含任意数量的附加线程。</p>
</li>
<li><p>程序</p>
<p>可以运行代码和资源以执行某些任务的组合。程序无需具有图形用户界面，尽管图形应用程序也被视为程序。</p>
</li>
<li><p>递归锁</p>
<p>可以由同一线程多次锁定的锁。</p>
</li>
<li><p>运行循环</p>
<p>事件处理循环，在此循环中，事件被接收并调度到适当的处理程序。</p>
</li>
<li><p>运行循环模式</p>
<p>与特定名称关联的输入源，计时器源和运行循环观察器的集合。当以特定的“模式”运行时，运行循环仅监视与该模式关联的源和观察者。</p>
</li>
<li><p>运行循环对象</p>
<p><code>NSRunLoop</code>类或<code>CFRunLoopRef</code>不透明类型的实例。这些对象提供了用于在线程中实现事件处理循环的接口。</p>
</li>
<li><p>运行循环观察器</p>
<p>运行循环执行的不同阶段中的通知的接收者。</p>
</li>
<li><p>信号</p>
<p>受保护的变量，用于限制对共享资源的访问。互斥量和条件都是信号灯的不同类型。</p>
</li>
<li><p>任务</p>
<p>要执行的工作量。</p>
</li>
<li><p>线</p>
<p>流程中的执行流程。每个线程都有自己的堆栈空间，但在同一进程中与其他线程共享内存。</p>
</li>
<li><p>计时器源</p>
<p>线程的同步事件的源。计时器在预定的将来时间生成一次或重复事件。</p>
</li>
</ul>
<h2 id="文档修订历史"><a href="#文档修订历史" class="headerlink" title="文档修订历史"></a>文档修订历史</h2><p>下表描述了对《<em>线程编程指南》</em>的更改。</p>
<table>
<thead>
<tr>
<th><strong>日期</strong></th>
<th><strong>笔记</strong></th>
</tr>
</thead>
<tbody><tr>
<td>2014-07-15</td>
<td>从线程安全的类列表中删除了 NSXMLDocument。</td>
</tr>
<tr>
<td>2013-10-22</td>
<td>将 NSXMLParser 和 NSXMLDocument 添加到线程安全对象列表。</td>
</tr>
<tr>
<td>2013-08-08</td>
<td>删除了过时的信息。</td>
</tr>
<tr>
<td>2010-04-28</td>
<td>更正了错别字。</td>
</tr>
<tr>
<td>2009-05-22</td>
<td>有关操作对象的信息已移至《并发编程指南》。仅将本书重点放在线程上。</td>
</tr>
<tr>
<td>2008-10-15</td>
<td>更新了有关操作对象和操作队列的示例代码。</td>
</tr>
<tr>
<td>2008-03-21</td>
<td>已针对 iOS 更新。</td>
</tr>
<tr>
<td>2008-02-08</td>
<td>对线程相关的概念和任务进行了重大的重写和更新。</td>
</tr>
<tr>
<td></td>
<td>添加了有关配置线程的更多信息。</td>
</tr>
<tr>
<td></td>
<td>将同步工具部分重组为一章，并添加了有关原子操作，内存屏障和易失变量的信息。</td>
</tr>
<tr>
<td></td>
<td>添加了有关运行循环的使用和配置的更多详细信息。</td>
</tr>
<tr>
<td></td>
<td>更改了<em>多线程编程主题中的</em>文档标题。</td>
</tr>
<tr>
<td>2007-10-31</td>
<td>添加了有关 NSOperation 和 NSOperationQueue 对象的信息。</td>
</tr>
<tr>
<td>2006-04-04</td>
<td>添加了一些新准则并更新了有关运行循环的信息。验证了分布式目标代码示例的准确性，并在其他几篇文章中更新了代码示例。</td>
</tr>
<tr>
<td>2005-03-03</td>
<td>更新了端口示例，以使用 NSPort 而不是 NSMessagePort。</td>
</tr>
<tr>
<td>2005-01-11</td>
<td>重组文章和扩展文档，使其不仅涵盖可可线程技术。</td>
</tr>
<tr>
<td></td>
<td>更新了线程概念信息，并添加了涵盖 OS X 中不同线程包的信息。</td>
</tr>
<tr>
<td></td>
<td>合并了 Core Foundation 多线程文档中的材料。</td>
</tr>
<tr>
<td></td>
<td>添加了有关在线程之间执行基于套接字的通信的信息。</td>
</tr>
<tr>
<td></td>
<td>添加了有关创建和使用 Carbon 线程的示例代码和信息。</td>
</tr>
<tr>
<td></td>
<td>添加了线程安全准则。</td>
</tr>
<tr>
<td></td>
<td>添加了有关 POSIX 线程和锁的信息。</td>
</tr>
<tr>
<td></td>
<td>添加了示例代码，以演示基于端口的通信。</td>
</tr>
<tr>
<td></td>
<td>本文档替换了以前在“ <em>多</em>线程”中发布的有关线程的信息。</td>
</tr>
<tr>
<td>2003-07-28</td>
<td>更新了有关在第三方库中使用锁的建议。</td>
</tr>
<tr>
<td>2003-04-08</td>
<td>在第三方库中有关锁定/解锁平衡的已重述信息。</td>
</tr>
<tr>
<td>2002-11-12</td>
<td>修订历史记录已添加到现有主题。</td>
</tr>
</tbody></table>

    </div>

    
    
    
      
  <div class="popular-posts-header">Related Posts</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/Concurrency-Programming-Guide/" rel="bookmark">Concurrency Programming Guide</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/ios-7-programming-cookbook/" rel="bookmark">iOS 7 Programming Cookbook</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/Pull-to-Refresh-UIViewController-in-iOS/" rel="bookmark">Pull to Refresh UIViewController in iOS</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/iOS-CI-Jenkins-Phabricator-Slack/" rel="bookmark">iOS CI (Jenkins + Phabricator + Slack)</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/View-blurred-after-CGAffineTransformMakeRotation/" rel="bookmark">View blurred after CGAffineTransformMakeRotation</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me 👨‍💻 a coffee ☕️</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/wechat.png" alt="LeiHao WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/alipay.png" alt="LeiHao Alipay">
        <span>Alipay</span>
      </div>
      <div>
        <img src="https://raw.githubusercontent.com/LeiHao0/BlogAssets/assets/bitcoin.png" alt="LeiHao Bitcoin">
        <span>Bitcoin</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Interview/" rel="tag"># Interview</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Concurrency-Programming-Guide/" rel="prev" title="Concurrency Programming Guide">
                  <i class="fa fa-chevron-left"></i> Concurrency Programming Guide
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/iOS-Token-Based-APNs/" rel="next" title="iOS Token-Based APNs">
                  iOS Token-Based APNs <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2012 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-laptop-code"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeiHao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Symbols count total">421k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">6:22</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>












  








  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://Artwalk.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://leihao0.github.io/Threading-Programming-Guide/";
    this.page.identifier = "Threading-Programming-Guide/";
    this.page.title = "Threading Programming Guide";
    };
  NexT.utils.loadComments('#disqus_thread', () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://Artwalk.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
